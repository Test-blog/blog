H2#@What is Design Pattern?Design patterns are optimized, reusable solutions to the programming problems that we encounter every day. A design pattern is not a class or a library that we can simply plug into our system; it's much more than that. It is a template that has to be implemented in the correct situation. It's not language-specific either. A good design pattern should be implementable in most-if not all-languages, depending on the capabilities of the language. Most importantly, any design pattern can be a  double-edged sword- if implemented in the wrong place, it can be disastrous and create many problems for you. However, implemented in the right place, at the right time,  it can be your savior.There are three basic kinds of design patterns:H4#@1.	structuralStructural patterns generally deal with relationships between entities, making it easier for these entities to work together.H4#@2.	creationalCreational patterns provide instantiation mechanisms, making it easier to create objects in a way that suits the situation.H4#@3.	behavioralBehavioral patterns are used in communications between entities and make it easier and more flexible for these entities to communicate.H4#@Why should we use them?Design patterns are, by principle, well-thought out solutions to programming problems. Many programmers have encountered these problems before, and have used these 'solutions' to remedy them. If you encounter these problems, why recreate a solution when you can use an already proven answer?H1#@1.	Strategy Design PatternThe Strategy pattern is known as a behavioural pattern - it's used to manage algorithms, relationships and responsibilities between objects. The definition of Strategy provided in the original Gang of Four book on Design Patterns states: b#@img#@http://java.dzone.com/sites/all/files/strategy_pattern.pngb#@H4#@How Does It Work In Java?Let's use the example of a file compression tool - where we create either zip or rar files. First we'll need a strategy: CODE_START#START_SNIPPET//Strategy Interfacepublic interface CompressionStrategy{   public void compressFiles(ArrayList<File> files);}CODE_END#And we'll need to provide our two implementations, one for zip and one for rarCODE_START#START_SNIPPETpublic class ZipCompressionStrategy implements CompressionStrategy{     public void compressFiles(ArrayList<File> files)   {     //using ZIP approach   }}CODE_END#CODE_START#START_SNIPPETpublic class RarCompressionStrategy implements CompressionStrategy{     public void compressFiles(ArrayList<File> files)   {     //using RAR approach   }}CODE_END#Our context will provide a way for the client to compress the files. Let's say that there is a preferences setting in our application that sets which compression algorithm to use. We can change our strategy using the setCompressionStrategy method in the Context.CODE_START#START_SNIPPETpublic class CompressionContext{   private CompressionStrategy strategy;      //this can be set at runtime by the application preferences   public void setCompressionStrategy(CompressionStrategy strategy)    {       this.strategy = strategy;     }  //use the strategy   public void createArchive(ArrayList<File> files)    {        strategy.compressFiles(files);   }}CODE_END#It's obvious that all the client has to do now is pass through the files to the CompressionContextCODE_START#START_SNIPPETpublic class Client{   public static void main(String[] args)   {      CompressionContext ctx = new CompressionContext();      //we could assume context is already set by preferences       ctx.setCompressionStrategy(new ZipCompressionStrategy());          //get a list of files     ...     ctx.createArchive(fileList);        }} CODE_END#H1#@2.	The Observer PatternBefore we get into the theory and code behind the Observer, let's take a look at a real world example, such as RSS feeds.  When I want to get updates from a particular feed, I add it to my feed reader. Any time that the RSS feed has an update, it will appear in my reader automatically.  This is the Observer pattern in action, a publisher/subscriber relationship with one source having many subscribers. The Observer is known as a behavioural pattern, as it's used to form relationships between objects at runtime.  The definition provided in the original Gang of Four book on Design Patterns states:H4#@Where Would I Use This Pattern?In general, you want to use this pattern to reduce coupling. If you have an object that needs to share it's state with others, without knowing who those objects are, the Observer is exactly what you need.You'll have seen, and probably used, the Observer many times if you've done any UI programming, especially in Swing. The whole concept of listeners is based on this pattern. The event listener is the most popular, where you register an ActionListener to a UI control, such a button, and react to action events using the actionPerformed method. In this case, the ActionListener is the Observer and the button is your Subject. As the button changes state, you can react, if you choose to, in your actionPerformed method. The typical real world uses of the pattern all revolve around this type of event handling system. b#@img#@http://java.dzone.com/sites/all/files/observer_pattern_java_0.PNGb#@The slight difference from the classic definition is that Observable is used in place of the Subject and is implemented as a class, while the Observer interface remains the same. Let's take a look at an implementation of the pattern with a real example. In our example, the subject will be a DataStore, with a Screen class as the observer.First, let's make our DataStore class observable by extending the java.util.Observable class. This means that our DataStore has all the methods and functionality available to make it a Subject, according to our pattern. CODE_START#START_SNIPPETimport java.util.Observable;public class DataStore extends Observable{		private String data;		public String getData()	{		return data;	}		public void setData(String data)	{		this.data =data;		//mark the observable as changed		setChanged();	}	}CODE_END#You'll notice that we have called the setChanged() method of the Observable. This is necessary in order for the call to notify observers to send out the update. Without this set, the Observable will see no reason to send out the update. Next, let's create our Observer. To do this, all we need to do is implement the Observer interface which forces us to write an update method, to deal with changes in the Observable's state. CODE_START#START_SNIPPETpublic class Screen implements Observer {	@Override	public void update(Observable o, Object arg) {		//act on the update	}}CODE_END#Adding our Screen as an observer to the DataStore is simple: CODE_START#START_SNIPPETScreen screen = new Screen();DataStore dataStore = new DataStore();//register observer dataStore.addObserver(screen);CODE_END#When the data changes, we want to notify all observers of this object. To do this, we just need to call the notifyObservers method when we want an update sent out CODE_START#START_SNIPPET//send a notificationdataStore.notifyObservers();CODE_END#H1#@3.	Builder design patternBuilder pattern is a creational design pattern it means its solves problem related to object creation. Constructors in Java are used to create object and can take parameters required to create object. Problem starts when an Object can be created with lot of parameters, some of them may be mandatory and others may be optional. Consider a class which is used to create Cake, now you need number of item like egg, milk, flour to create cake. many of them are mandatory and some  of them are optional like cherry, fruits etc. If we are going to have overloaded constructor for different kind of cake then there will be many constructor and even worst they will accept many parameter.H4#@Problems:1) too many constructors to maintain.2) error prone because many fields has same type e.g. sugar and and butter are in cups so instead of 2 cup sugar if you pass 2 cup butter, your compiler will not complain but will get a buttery cake with almost no sugar with high cost of wasting butter.You can partially solve this problem by creating Cake and then adding ingredients but that will impose another problem of leaving Object on inconsistent state during building, ideally cake should not be available until its created. Both of these problem can be solved by using Builder design pattern in Java. Builder design pattern not only improves readability but also reduces chance of error by adding ingredients explicitly and making object available once fully constructed. We will use same example of creating Cake using Builder design pattern in Java. here we have static nested builder class inside Cake which is used to create object.H4#@Guidelines for Builder design pattern in Java1) Make a static nested class called Builder inside the class whose object will be build by Builder. In this example its Cake.2) Builder class will have exactly same set of fields as original class.3) Builder class will expose method for adding ingredients e.g. sugar() in this example. each method will return same Builder object. Builder will be enriched with each method call.4) Builder.build() method will copy all builder field values into actual class and return object of Item class.5) Item class (class for which we are creating Builder) should have private constructor to create its object from build() method and prevent outsider to access its constructor.CODE_START#START_SNIPPETpublic class BuilderPatternExample {      public static void main(String args[]) {              //Creating object using Builder pattern in java        Cake whiteCake = new Cake.Builder().sugar(1).butter(0.5).  eggs(2).vanila(2).flour(1.5). bakingpowder(0.75).milk(0.5).build();              //Cake is ready to eat :)        System.out.println(whiteCake);    }}class Cake {    private final double sugar;   //cup    private final double butter;  //cup    private final int eggs;    private final int vanila;     //spoon    private final double flour;   //cup    private final double bakingpowder; //spoon    private final double milk;  //cup    private final int cherry;    public static class Builder {        private double sugar;   //cup        private double butter;  //cup        private int eggs;        private int vanila;     //spoon        private double flour;   //cup        private double bakingpowder; //spoon        private double milk;  //cup        private int cherry;        //builder methods for setting property        public Builder sugar(double cup){this.sugar = cup; return this; }        public Builder butter(double cup){this.butter = cup; return this; }        public Builder eggs(int number){this.eggs = number; return this; }        public Builder vanila(int spoon){this.vanila = spoon; return this; }        public Builder flour(double cup){this.flour = cup; return this; }        public Builder bakingpowder(double spoon){this.sugar = spoon; return this; }        public Builder milk(double cup){this.milk = cup; return this; }        public Builder cherry(int number){this.cherry = number; return this; }                    //return fully build object        public Cake build() {            return new Cake(this);        }    }    //private constructor to enforce object creation through builder    private Cake(Builder builder) {        this.sugar = builder.sugar;        this.butter = builder.butter;        this.eggs = builder.eggs;        this.vanila = builder.vanila;        this.flour = builder.flour;        this.bakingpowder = builder.bakingpowder;        this.milk = builder.milk;        this.cherry = builder.cherry;           }    @Override    public String toString() {        return "Cake{" + "sugar=" + sugar + ", butter=" + butter + ", eggs=" + eggs + ", vanila=" + vanila + ", flour=" + flour + ", bakingpowder=" + bakingpowder + ", milk=" + milk + ", cherry=" + cherry + '}';    }   }Output:Cake{sugar=0.75, butter=0.5, eggs=2, vanila=2, flour=1.5, bakingpowder=0.0, milk=0.5, cherry=0}CODE_END#Builder design pattern in Java – Pros and ConsLive everything Builder pattern also has some disadvantages, but if you look at below, advantages clearly outnumber disadvantages of Builder design pattern. Any way here are few advantages and disadvantage of Builder design pattern for creating objects in Java.H4#@Advantages:1) more maintainable if number of fields required to create object is more than 4 or 5.2) less error-prone as user will know what they are passing because of explicit method call.3) more robust as only fully constructed object will be available to client.H4#@Disadvantages:1) verbose and code duplication as Builder needs to copy all fields from Original or Item class.When to use Builder Design pattern in JavaBuilder Design pattern is a creational pattern and should be used when number of parameter required in constructor is more than manageable usually 4 or at most 5. Don't confuse with Builder and Factory pattern there is an obvious difference between Builder and Factory pattern, as Factory can be used to create different implementation of same interface but Builder is tied up with its Container class and only returns object of Outer class.That's all on Builder design pattern in Java. we have seen why we need Builder pattern , what problem it solves, Example of builder design pattern in Java and finally when to use Builder patter with pros and cons. So if you are not using telescoping constructor pattern or have a choice not to use it than Builder pattern is way to go.H1#@Java Decorator Design PatternH4#@What is decorator design pattern in Java?1. Decorator design pattern is used to enhance the functionality of a particular object at run-time or dynamically.2. At the same time other instance of same class will not be affected by this so individual object gets the new behavior.3. Basically we wrap the original object through decorator object.4. Decorator design pattern is based on abstract classes and we derive concrete implementation from that classes,5. It’s a structural design pattern and most widely used.H4#@Problem which is solved by Decorator Pattern:decorator design pattern java example codeNow the question is why this pattern has came into existence what is the problem with existing system, so the answer is if anyone wants to add some functionality to individual object or change the state of particular object at run time it is not possible what the possible is we can provide the specific behavior to all the object of that class at design time by the help of inheritance or using subclass, but Decorator pattern makes possible that we provide individual object of same class a specific behavior or state at run time. This doesn’t affect other object of same Class in Java.H4#@When to use Decorator pattern in Java1. When sub classing is become impractical and we need large number of different possibilities to make independent object or we can say we have number of combination for an object.2. Secondly when we want to add functionality to individual object not to all object at run-time we use decorator design pattern.H4#@Code Example of decorator design pattern:To better understand concept of decorator design pattern let see a code example using Decorator Pattern in Java. You can also look inside JDK and find what are classes and packages which are using decorator pattern.CODE_START#START_SNIPPET// Component on Decorator design patternpublic abstract class Currency { String description = "Unknown currency"; public String getCurrencyDescription() {  return description; } public abstract double cost(double value);}// Concrete Componentpublic class Rupee extends Currency {double value; public Rupee() {  description = "indian rupees"; } public double cost(double v){  value=v;  return value; }}//Another Concrete Componentpublic class Dollar extends Currency{double value; public Dollar () {  description = "Dollar”; }public double cost(double v){ value=v;  return value; }}// Decoratorpublic abstract class Decorator extends Currency{ public abstract String getDescription();}// Concrete Decoratorpublic class USDDecorator extends Decorator{ Currency currency;  public USDDecorator(Currency currency){  this.currency = currency; } public String getDescription(){  return currency.getDescription()+" ,its US Dollar"; }}//Another Concrete Decoratorpublic class SGDDecorator extends Decorator{ Currency currency; public SGDDecorator(Currency currency){  this.currency = currency; } public String getDescription(){  return currency.getDescription()+" ,its singapore Dollar"; }}Now its time to check currency.public class CurrencyCheck { public static void main(String[] args) {  // without adding decorators  Currency curr = new Dollar();  System.out.println(curr.getDescription() +" dollar. "+curr.cost(2.0));      //adding decorators  Currency curr2 = new USDDecorator(new Dollar());  System.out.println(curr2.getDescription() +" dollar. "+curr2.cost(4.0));Currency curr3 = new SGDDecorator(new Dollar());  System.out.println(curr3.getDescription() +" dollar. "+curr3.cost(4.0));}CODE_END#H4#@Advantage of Decorator design Pattern in JavaIn brief we see what the main advantages of using decorator design patterns are.1.      Decorator Pattern is flexible than inheritance because inheritance add responsibilities at compile time and it will add at run-time.2.      Decorator pattern enhance or modify the object functionalityH4#@DisadvantageMain disadvantage of using Decorator Pattern in Java is that the code maintenance can be a problem as it provides a lot of similar kind of small objects (each decorator).H1#@Facade Design PatternFacade pattern hides the complexities of the system and provides an interface to the client using which the client can access the system. This type of design pattern comes under structural pattern as this pattern adds an interface to exiting system to hide its complexities.This pattern involves a single class which provides simplified methods which are required by client and delegates calls to existing system classes methods.H4#@ImplementationWe're going to create a Shape interface and concrete classes implementing the Shape interface. A facade class ShapeMaker is defined as a next step.ShapeMaker class uses the concrete classes to delegates user calls to these classes. FacadePatternDemo, our demo class will use ShapeMaker class to show the results.img#@http://www.tutorialspoint.com/design_pattern/images/facade_pattern_uml_diagram.jpgCODE_START#START_SNIPPET//Step 1 : Create an interface.//Shape.javapublic interface Shape {   void draw();}//Step 2: Create concrete classes implementing the same interface.//Rectangle.javapublic class Rectangle implements Shape {   @Override   public void draw() {      System.out.println("Rectangle::draw()");   }}//Square.javapublic class Square implements Shape {   @Override   public void draw() {      System.out.println("Square::draw()");   }}//Circle.javapublic class Circle implements Shape {   @Override   public void draw() {      System.out.println("Circle::draw()");   }}//Step 3: Create a facade class.ShapeMaker.javapublic class ShapeMaker {   private Shape circle;   private Shape rectangle;   private Shape square;   public ShapeMaker() {      circle = new Circle();      rectangle = new Rectangle();      square = new Square();   }   public void drawCircle(){      circle.draw();   }   public void drawRectangle(){      rectangle.draw();   }   public void drawSquare(){      square.draw();   }}/*Step 4 : Use the facade to draw various types of shapes.*/FacadePatternDemo.javapublic class FacadePatternDemo {   public static void main(String[] args) {      ShapeMaker shapeMaker = new ShapeMaker();      shapeMaker.drawCircle();      shapeMaker.drawRectangle();      shapeMaker.drawSquare();		   }}//Step 5 : Verify the output.Circle::draw()Rectangle::draw()Square::drawCODE_END#