H3#@1.	How to check tree if binary tree is balanced tree:CODE_START#START_SNIPPETgetHeight(Node node){	if(node==null){return 0;}	return Math.max(getHeight(node.left),getHeight(node.right))+1;}boolean isBalanced(Node node){	int height = getHeight(node.left) - getHeight(node.right);	if(height>1){return false;}	else{	isBalanced(node.left) && isBalanced(node.right);}CODE_END#H3#@2.	Reverse doubly linked list.CODE_START#START_SNIPPET/* Function to reverse a Doubly Linked List */void reverse(struct node **head_ref){     struct node *temp = NULL;       struct node *current = *head_ref;           /* swap next and prev for all nodes of        doubly linked list */     while (current !=  NULL)     {       temp = current->prev;       current->prev = current->next;       current->next = temp;                     current = current->prev;     }          }     CODE_END#H3#@3. BFS TraversalH4#@BFS using QueueCODE_START#START_SNIPPETprintLevelorder(tree)1) Create an empty queue q2) temp_node = root /*start from root*/3) Loop while temp_node is not NULL    a) print temp_node->data.    b) Enqueue temp_node's children (first left then right children) to q    c) Dequeue a node from q and assign it's value to temp_nodeCODE_END#H4#@BFS without using Queue: RecursiveCODE_START#START_SNIPPET/*Function to print level order traversal of tree*/printLevelorder(tree)for d = 1 to height(tree)   printGivenLevel(tree, d);/*Function to print all nodes at a given level*/printGivenLevel(tree, level)if tree is NULL then return;if level is 1, then    print(tree->data);else if level greater than 1, then    printGivenLevel(tree->left, level-1);    printGivenLevel(tree->right, level-1);CODE_END#H3#@4. Check if binary tree is BST.1. In order Traversal2. Make sure :  INTEGER_MIN < left node child < current.node  (isthisBSTUtil(root->left, min, root->data))3. And make sureL current.node < right  node child < INTEGER.MAX (isthis BSTUtil(root->right,root->data, max)CODE_START#START_SNIPPETbool isthisBST(nodeptr root){	return isthisBSTUtil(root,INT_MIN, INT_MAX);}int isthisBSTUtil(nodeptr root, int min, int max){	if(root == NULL) return true; //empty tree is a bst	if(root-data < min || root->data >max) return false;	return (isthisBSTUtil(root->left, min, root->data) || isthis BSTUtil(root->right,root->data, max);}CODE_END#H3#@Perform binary searchCODE_START#START_SNIPPETpublic static int binarySearch( Comparable [ ] a, Comparable x )    {        int low = 0;        int high = a.length - 1;        int mid;        while( low <= high )        {            mid = ( low + high ) / 2;            if( a[ mid ].compareTo( x ) < 0 )                low = mid + 1;            else if( a[ mid ].compareTo( x ) > 0 )                high = mid - 1;            else                return mid;        }        return NOT_FOUND;     // NOT_FOUND = -1	}CODE_END#H3#@5. Find or determine non existence of a number in a sorted list of N numbers where the numbers range over M, M >> N and N large enough to span multiple disks. Algorithm to beat O(log n) bonus points for constant time algorithm.This problem can be solved using bitmaps.bitmap will be an array (say b_array) where we have one bit per M possible number. If we use a character array to store bitmaps, b_array size will be M/8, since 1 char can store 8 bits. Bitmap array will be initialized to zero first. Now for each of the N numbers its corresponding bit should be turned on(1). Corresponding bit for 'n' can be found as follows:CODE_START#START_SNIPPETbase = n/8; (base is the char whose certain bit needs to be set)offset = 1 << (n mod 8); (offset is the bit to be set)b_array[base] |= offset; (I set the particular bit)Once this is done of all N numbers, given a number m,we can first find corresponding  bit offset and check whether it is one.base = m/8; (base is the char whose certain bit needs to be set)offset = 1 << (m mod 8); (offset is the bit to be set)if (b_array[base] & offset)    // found the numberelse    //number could not be foundCODE_END#H3#@6. Find height of Binary tree without recursion CODE_START#START_SNIPPETint maxDepthIterative(BinaryTree *root) {  if (!root) return 0;  stack<BinaryTree*> s;  s.push(root);  int maxDepth = 0;  BinaryTree *prev = NULL;  while (!s.empty()) {    BinaryTree *curr = s.top();    if (!prev || prev->left == curr || prev->right == curr) {      if (curr->left)        s.push(curr->left);      else if (curr->right)        s.push(curr->right);    } else if (curr->left == prev) {      if (curr->right)        s.push(curr->right);    } else {      s.pop();    }    prev = curr;    if (s.size() > maxDepth)      maxDepth = s.size();  }  return maxDepth;}CODE_END#H3#@7. Convert Binary Search to Doubly linked listCODE_START#START_SNIPPET			1		2		3	4	   5[1] Do in order traversaltraversal(node.left)Logictraversal(node.right)[2] Logic(a) need to link left of list as Previous node of our in-order traversal, i.e.: for 2 left = previous 4(b) and for 4 left = null so, 4 should be head.4-2-5-1-3 void convertBSTToDLL(treenode* curNode, treenode*& prevNode, treenode*& listHead){    if (curNode)    {		//[1] Traversal left        convertBSTToDLL(curNode->left, prevNode, listHead);				//[2] Logic        if (prevNode)        {            curNode->left = prevNode;            prevNode->right = curNode;        }        else        {            listHead = curNode;        }        prevNode = curNode;				//[3] Traversal right        convertBSTToDLL(curNode->right, prevNode, listHead);    }    return;}CODE_END#H3#@8.	Convert  decimal to binaryCODE_START#START_SNIPPETimport java.util.*;public class number{	public static void main (String [] args)	{		Scanner input = new Scanner (System.in);		System.out.println ("Input decimal number");		int decimal = input.nextInt ();		input.close ();				int base = 2;		int result = 0;		int multiplier = 1;				while (decimal>0)		{			int residue = decimal%base;			decimal = decimal/base;			result = result +residue*multiplier;			multiplier = multiplier * 10;		}		System.out.println ("binary....."+result);	}}CODE_END#H3#@9.	COnvert decimal to HexCODE_START#START_SNIPPETfunction toHex(d) {  var r = d % 16;  var result;  if (d-r == 0)     result = toChar(r);  else     result = toHex( (d-r)/16 ) + toChar(r);  return result;} function toChar(n) {  const alpha = "0123456789ABCDEF";  return alpha.charAt(n);}CODE_END#H3#@10.	Write DFS using stack.CODE_START#START_SNIPPETpublic void dfs(){	//DFS uses Stack data structure	Stack s=new Stack();	s.push(this.rootNode);	rootNode.visited=true;	printNode(rootNode);	while(!s.isEmpty())	{		Node n=(Node)s.peek();		Node child=getUnvisitedChildNode(n);		if(child!=null)		{			child.visited=true;			printNode(child);			s.push(child);		}		else		{			s.pop();		}	}	//Clear visited property of nodes	clearNodes();}CODE_END#H3#@11.	Write BFS using queueCODE_START#START_SNIPPETpublic void bfs(){	//BFS uses Queue data structure	Queue q=new LinkedList();	q.add(this.rootNode);	printNode(this.rootNode);	rootNode.visited=true;	while(!q.isEmpty())	{		Node n=(Node)q.remove();		Node child=null;		while((child=getUnvisitedChildNode(n))!=null)		{			child.visited=true;			printNode(child);			q.add(child);		}	}	//Clear visited property of nodes	clearNodes();}CODE_END#H3#@12. Given a sorted array of integers, how can you find the location of a particular integer x?Use binary search. Compare the number in the middle of the arraywith x. If it is equal, we are done. If the number is greater, we know to look in thesecond half of the array. If it is smaller, we know to look in the first half. We canrepeat the search on the appropriate half of the array by comparing the middleelement of that array with x, once again narrowing our search by a factor of 2. Werepeat this process until we find x. This algorithm takes O(log n) time.H3#@13.	What is Mutexes and semaphores:bo#@Mutex:A mutex is like a lock. Mutexes are used in parallel programming to ensure that onlyone thread can access a shared resource at a time. For example, say one thread ismodifying an array. When it has gotten halfway through the array, the processorswitches to another thread. If we were not using mutexes, the thread might try tomodify the array as well, which is probably not what we want.b#@To prevent this, we could use a mutex. Conceptually, a mutex is an integer thatstarts at 1. Whenever a thread needs to alter the array, it "locks" the mutex. Thiscauses the thread to wait until the number is positive and then decreases it by one.When the thread is done modifying the array, it "unlocks" the mutex, causing thenumber to increase by 1. If we are sure to lock the mutex before modifying thearray and to unlock it when we are done, then we know that no two threads willmodify the array at the same time.b#@bo#@SemaphoresSemaphores are more general than mutexes. They differ only in that a semaphore'sinteger may start at a number greater than 1. The number at which a semaphorestarts is the number of threads that may access the resource at once. Semaphoressupport "wait" and "signal" operations, which are analogous to the "lock" and"unlock" operations of mutexes.H3#@14.	Write a function to convert a string into an integer.Go through the string from beginning to end. If the first character is anegative sign, remember this fact. Keep a running total, which starts at 0. Each timeyou reach a new digit, multiply the total by 10 and add the new digit. When youreach the end, return the current total, or, if there was a negative sign, the inverse ofthe number.H3#@15.	Merge SortMerge sort is a recursive way to sort an array. First, you divide the array in half andrecursively sort each half of the array. Then, you combine the two halves into asorted array. So a merge sort function would look something like this:img#@http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gifCODE_START#START_SNIPPETvoid mergeSort(int numbers[], int temp[], int array_size){        m_sort(numbers, temp, 0, array_size - 1);}void m_sort(int numbers[], int temp[], int left, int right){       int mid;        if (right > left)        {            mid = (right + left) / 2;            m_sort(numbers, temp, left, mid);            m_sort(numbers, temp, mid+1, right);            merge(numbers, temp, left, mid+1, right);        }}void merge(int numbers[], int temp[], int left, int mid, int right)        {           int i, left_end, num_elements, tmp_pos;           left_end = mid - 1;            tmp_pos = left;            num_elements = right - left + 1;while ((left <= left_end) && (mid <= right))        {                if (numbers[left] <= numbers[mid])                {                        temp[tmp_pos] = numbers[left];                        tmp_pos = tmp_pos + 1;                        left = left +1;                }                else                {                        temp[tmp_pos] = numbers[mid];                        tmp_pos = tmp_pos + 1;                        mid = mid + 1;                }        }        while (left <= left_end)                {                        temp[tmp_pos] = numbers[left];                        left = left + 1;                        tmp_pos = tmp_pos + 1;                }                while (mid <= right)                {                        temp[tmp_pos] = numbers[mid];                        mid = mid + 1;                        tmp_pos = tmp_pos + 1;                }                for (i = 0; i <= num_elements; i++)                {                        numbers[right] = temp[right];                        right = right - 1;                }        }CODE_END#H3#@16.	Write a program to determine whether an input string x is a substring of another input string y.CODE_START#START_SNIPPETbool hasSubstring(const char *str, const char *find) {	if (str[0] == '\0' && find[0] == '\0')		return true;	for(int i = 0; str[i] != '\0'; i++) {		bool foundNonMatch = false;		for(int j = 0; find[j] != '\0'; j++) {			if (str[i + j] != find[j]) {			foundNonMatch = true;			break;			}		}	if (!foundNonMatch)	return true;	}	return false;}CODE_END#H3#@17.	Write program : non-recursive in-order traversalCODE_START#START_SNIPPETvoid inorder( node *root){	node *p;	p=root;	top=0;	do	{		while(p!=NULL)		{			stk[top]=p->data;			top++;			p=p->left;		}		if(top>0)		{			p=pop(root);			cout << p->data;			p=p->right;		}	}while(top!=0 || p!=NULL);}CODE_END#H3#@18.	Find 5th largest element from BST.CODE_START#START_SNIPPETint num=0;void max(tree*t){        if(t==NULL)                return;        max(t->right);        num++;        if(num==5)                printf("%d\n",t->no);        max(t->left);}CODE_END#H3#@19.	FInd lowest common ancestor for two nodes in binary tree.CODE_START#START_SNIPPETtreeNodePtr findLCA(treeNodePtr root, treeNodePtr p, treeNodePtr q) {        // no root no LCA.        if(!root) {                return NULL;        }        // if either p or q is the root then root is LCA.        if(root==p || root==q) {                return root;        } else {                // get LCA of p and q in left subtree.                treeNodePtr l=findLCA(root->left , p , q);                // get LCA of p and q in right subtree.                treeNodePtr r=findLCA(root->right , p, q);                // if one of p or q is in leftsubtree and other is in right                // then root it the LCA.                if(l && r) {                        return root;                }                // else if l is not null, l is LCA.                else if(l) {                        return l;                } else {                        return r;                }        }}CODE_END#H3#@20.	Print possible closed parenthesis pairs program.i.e.: Pair = 3Combinations should be:((())))(()())(())()()(())()()()CODE_START#START_SNIPPETpublic class App {	 static int total = 3;	    static private void Brackets(String output, int open, int close, int pairs) {	        if ((open == pairs) && (close == pairs) && output.length() == total * 2) {	            System.out.println(output);	        } else {	            if (open < pairs)	                Brackets(output + "(", open + 1, close, pairs);	            if (close < open)	                Brackets(output + ")", open, close + 1, pairs);	        }	    }	    public static void main(String[] args) {	        Brackets("", 0, 0, 3);	    }}CODE_END#H3#@21. Permutation for a given characters.CODE_START#START_SNIPPETpublic class Permute {	void permute( String str ){	    int          length = str.length();	    boolean[]    used = new boolean[ length ];	    StringBuffer out = new StringBuffer();	    char[]       in = str.toCharArray();	    doPermute( in, out, used, length, 0 );	}	void doPermute( char[] in, StringBuffer out,	                boolean[] used, int length, int level ){	    if( level == length ){	        System.out.println( out.toString() );	        return;	    }	    for( int i = 0; i < length; ++i ){	        if( used[i] ) continue;	        out.append( in[i] );	        used[i] = true;	        doPermute( in, out, used, length, level + 1 );	        used[i] = false;	        out.setLength( out.length() - 1 );	    }	}	}CODE_END#H3#@22. Design a class library for writing card games.CODE_START#START_SNIPPETpublic class Card{    private short rank, suit;    private static String[] suits = { "hearts", "spades", "diamonds", "clubs" };    private static String[] ranks  = { "Ace", "2", "3", "4", "5", "6", "7",                    "8", "9", "10", "Jack", "Queen", "King" };    public static String rankAsString( int __rank ) {        return ranks[__rank];    }public short getRank() {         return rank;    }    public short getSuit() {        return suit;    }}(win)		isPair,isRed,handTotalgame- player - pile---|			|Deck-Icard------  Card(shuffle,		(getSuit,getRank)isFlush,handTotal)CODE_END#H3#@23. Define types of cookies.bo#@Session cookie:A session cookie only lasts for the duration of users using the website. A session cookie will expire if a user closes his/her browser, or if a user hasn't visited the server for certain period of time (called session idle timeout), and the server would expire/invalidate the user session.b#@bo#@Persistent cookie:A persistent cookie will outlast user sessions. If a persistent cookie has Max-Age set to 1 year, then, within the year, the initial value set in that cookie would be sent back to server every time the user is visiting the server. This could be used to record a vital piece of information such as how the user initially came to this website. For this reason, persistent cookie is also called tracking cookieb#@bo#@Secure cookie:A secure cookie is only used when a browser is visiting a server via HTTPS, that will make sure that cookie is always encrypted when transmitting from client to server, and therefore less likely to be exposed to cookie theft via eavesdropping.b#@bo#@HttpOnly cookie:HttpOnly cookie is still in IETF draft[8], though most of the modern browsers support it. On a supported browser, a HttpOnly cookie will only be used when transmitting HTTP (or HTTPS) requests, but the cookie value is not available to client side script, hence mitigate the threat of cookie theft via Cross-site scripting.b#@bo#@Third-party cookie:First-party cookies are cookies set with the same domain or its subdomain in your browser's address bar. Third-party cookies are cookies being set with different domains than the one shown on address bar.For example: Suppose a user visits www.example1.com, it sets a cookie with domain ad.foxytracking.com. When the user later visits www.example2.com, another cookie is placed with domain ad.foxytracking.com, eventually these cookies will be sent to the advertiser when loading their ads or visiting their website, the advertiser can then build up users' browsing history across all the websites this advertiser has footprints on.b#@bo#@Super cookie:A Super cookie is a cookie with a Public Suffix [9] domain, like .com, .co.uk or k12.ca.us.Most browsers, by default, allow first-party cookies, i.e., a cookie with domain to be the same or sub-domain of the requesting host. For example, a user visiting www.example.com can have a cookie set with domain www.example.com or .example.com, but not .com. A super cookie with domain .com would be blocked by browsers; otherwise, attacker.com could set a super cookie with domain .com and potentially disrupt or impersonate legitimate user requests to example.com. Unfortunately, the Public Suffix List keeps changing, and older versions of browsers will not have the most up-to-date list, and will therefore be vulnerable to certain super cookies.b#@bo#@Zombie cookie:A zombie cookie is any cookie that is automatically recreated after a user has deleted it. This is accomplished by a script storing the content of the cookie in some other location, such as the local storage available to Flash content, and then recreating it from the backup when the cookie's absence is detected.H3#@ Given two strings, check if one string is a permutation of the other.b#@ Solution 1: Sort the string and verifyb#@ Solution 2:  Check if the two strings have identical characters count.H3#@24.	ROTATE A MATRIX BY 90 DEGREESb#@[1,  2, 3, 4]                   [9, 6, 9, 1]b#@[9, 8, 5, 6]         –>       	[2, 5, 8, 2]b#@[6, 5, 3, 7]                    [6, 3, 5, 3]b#@[9, 2, 6, 8]                    [8, 7, 6, 4]b#@In our example we have two layers:b#@b#@OUTER LAYER         			 INNER LAYERb#@1 2 3 4b#@9      6                               8 5b#@6      7                               5 3b#@9 2 6 8At each layer we are gonna loop through the elements and swap them as follows:b#@1.- Save the ith element in the top array in a temporary variable (in our example the top array is [1 2 3 4] ).b#@2.- Move the ith element from left to top.b#@3.- Move the ith element from bottom to left.b#@4.- Move the ith element from right to bottom.b#@5.- Save the value of our temporary variable in the ith position in the right array.b#@Tip: Draw 4*4 matrix and run above steps on paper. It will tell you the solution.CODE_START#START_SNIPPETpublic static void rotate(int[][] matrix, int n) { for (int layer = 0; layer < n / 2; ++layer) {	int first = layer;	int last = n - 1 - layer;	for(int i = first; i < last; ++i) {		 int offset = i - first;		 int top = matrix[first][i]; // save top		 // left -> top		 matrix[first][i] = matrix[last-offset][first]; 		 		 // bottom -> left		 matrix[last-offset][first] = matrix[last][last - offset]; 		 		 // right -> bottom		 matrix[last][last - offset] = matrix[i][last]; 		 		 // top -> right		 matrix[i][last] = top; // right <- saved top		 } } }CODE_END#H3#@25.	Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column is set to 0.Track which column and row is having 0. and make all rows and columns 0 for that matrix.CODE_START#START_SNIPPET public static void setZeros(int[][] matrix) {	 int[] row = new int[matrix.length]; 	 int[] column = new int[matrix[0].length]; // Store the row and column index with value 0	for (int i = 0; i < matrix.length; i++) {		for (int j = 0; j < matrix[0].length;j++) {		 if (matrix[i][j] == 0) {		 row[i] = 1; 		 column[j] = 1;		 }	} }  // Set arr[i][j] to 0 if either row i or column j has a 0	 for (int i = 0; i < matrix.length; i++) {		 for (int j = 0; j < matrix[0].length; j++) {			 if ((row[i] == 1 || column[j] == 1)) {			 matrix[i][j] = 0;			 }		}	 } }CODE_END#H3#@26.	Assume you have a method isSubstring which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring (i.e., “waterbottle” is a rotation of “erbottlewat”).CODE_START#START_SNIPPET public static boolean isRotation(String s1, String s2) {	 int len = s1.length();	 /* check that s1 and s2 are equal length and not empty */	 if (len == s2.length() && len > 0) { 		 /* concatenate s1 and s1 within new buffer */		 String s1s1 = s1 + s1;		 return isSubstring(s1s1, s2);	 }	 return false; }CODE_END#H3#@27.	Given a directed graph, design an algorithm to find out whether there is a route between two nodes. This problem can be solved by just simple graph traversal, such as depth first search or breadth first search. Start one of the two nodes and traverse with BFS or DFS.CODE_START#START_SNIPPET	public static boolean search(Graph g, Node start, Node end) { 	LinkedList<Node> q = new LinkedList<Node>(); // operates as Stack 	for (Node u : g.getNodes()) { 	u.state = State.Unvisited; 	} 	start.state = State.Visiting; 	q.add(start); 	Node u; 	while(!q.isEmpty()) { 	u = q.removeFirst(); // i.e., pop() 	if (u != null) { 	for (Node v : u.getAdjacent()) { 		if (v.state == State.Unvisited) {		if (v == end) {		return true;		} else {		v.state = State.Visiting;		q.add(v);		}		}	} 	u.state = State.Visited; 	} } 	return false; CODE_END#H3#@28.	Given a sorted (increasing order) array, write an algorithm to create a binary tree with minimal height.We will try to create a binary tree such that for each node, the number of nodes in the left subtree and the right subtree are equal, if possible.b#@bo#@Algorithm:1.	Insert into the tree the middle element of the array. 2.	Insert (into the left subtree) the left subarray elements 3.	Insert (into the right subtree) the right subarray elements 4.	Recurse CODE_START#START_SNIPPETpublic static TreeNode addToTree(int arr[], int start, int end){ 	if (end < start) { 	return null; 	} 	int mid = (start + end) / 2; 	TreeNode n = new TreeNode(arr[mid]); 	n.left = addToTree(arr, start, mid - 1); 	n.right = addToTree(arr, mid + 1, end); 	return n; } public static TreeNode createMinimalBST(int array[]) { 	return addToTree(array, 0, array.length - 1); } CODE_END#H3#@29.	 Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each depth (eg, if you have a tree with depth D, you'll have D linked lists).CODE_START#START_SNIPPETArrayList<LinkedList<TreeNode>> findLevelLinkList(TreeNode root) { 	int level = 0; 	ArrayList<LinkedList<TreeNode>> result = new ArrayList<LinkedList<TreeNode>>(); 	LinkedList<TreeNode> list = new LinkedList<TreeNode>(); 	list.add(root); 	result.add(level, list); 	while (true) { 		list = new LinkedList<TreeNode>(); 		for (int i = 0; i < result.get(level).size(); i++) { 			TreeNode n = (TreeNode) result.get(level).get(i); 			if (n != null) { 				if(n.left !=	null)	list.add(n.left);				if(n.right!=	null)	list.add(n.right);			} 		} 			if (list.size() > 0) { 			result.add(level + 1, list); 		} else { 			break; 		} 		level++; 	} 	return result; } CODE_END#b#@We can also implement is with recurssive call.CODE_START#START_SNIPPETList<LinkedList<TreeNode>> createBreathLinkedList(TreeNode root){	List<LinkedList<TreeNode>> list = new ArrayList<LL<TreeNode>>();	createBreathListRecurssive(root,list,0/*root at 0 level*/);}void createBreathListRecurssive(TreeNode root, List<LinkedList<TreeNode>> lists,int level){		if(root==null){return null;}		LinkedList<TreeNode> list = null;	if(lists.size()==level) { /*we add breath linked list into list.so, each sub linked list at each level*/		list = new LinkedList<TreeNode>();		lists.add(list);	}else{		list = lists.get(level);	}	list.add(root);	createBreathListRecurssive(root.left,lists,level+1);	createBreathListRecurssive(root.right,lists,level+1);}CODE_END#H3#@30.	Check if binary tree is binary search tree.CODE_START#START_SNIPPETboolean checkBST(TreeNode n){	return checkBST(n,INT_MIN,INT_MAX);}boolean checkBST(TreeeNode node,int min,int max){		if(node==null){return true;}	int value = node.getValue();		if(value<=min || value>max){return false;}		if(!checkBST(node.left,min,value) || !checkBST(node.right,value,max)){return false;}	return true;	}CODE_END#H3#@31.	Write an algorithm to find the NEXT node (e.g., in-order successor) of a given node in a binary search tree where each node has a link to its parent. We will do in order traversal.b#@1.	If X has a right child, then the successor must be on the right side of X (because of the order in which we visit nodes). Specifically, the left-most child must be the first node visited in that subtree. 2.	Else, we go to X s parent (call it P). 2.a. If X was a left child (P.left = X), then P is the successor of X2.b. If X was a right child (P.right = X), then we have fully visited P, so we call successor(P).b#@CODE_START#START_SNIPPETpublic static TreeNode inorderSucc(TreeNode e) { 	if (e != null) { 	TreeNode p; 	// Found right children -> return 1st inorder node on right 	if (e.parent == null || e.right != null) { 		p = leftMostChild(e.right); 	} else { 	// Go up until we're on left instead of right (case 2b) 	while ((p = e.parent) != null) { 		if (p.left == e) { /* if node == node.parent.left -> then according to in-order parent is next*/		break;		}		e = p; /* else assign parent to e and traverse further up*/	} 	} 	return p; } return null; } public static TreeNode leftMostChild(TreeNode e) { 	if (e == null) return null; 	while (e.left != null) e = e.left; 	return e; } CODE_END#H3#@32.	Write a function to determine the number of bits required to convert integer A to integer B.1.	XOR A and B. --> It will give you how many bits are different2. Right shift by 1 and increment the count to calculate difference CODE_START#START_SNIPPETpublic static int bitSwapRequired(int a, int b) { int count = 0; for (int c = a ^ b; c != 0; c = c >> 1) { 	count += c & 1; } return count; } CODE_END#H3#@33.	Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, etc). Mask all odd bits with 10101010 in binary (which is 0xAA), then shift them left to put them in the even bits. Then, perform a similar operation for even bits. This takes a total 5 instructions.CODE_START#START_SNIPPETpublic static int swapOddEvenBits(int x) { 	return ( ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1) ); } CODE_END#H3#@34.	Given an input file with four billion integers, provide an algorithm to generate an integer which is not contained in the file. Assume you have 1 GB of memory.It's possible to find a missing integer with just two passes of the data set. We can divide up the integers into blocks of some size (we'll discuss how to decide on a size later). Let's just as-sume that we divide up the integers into blocks of 1000. So, block 0 represents the numbers 0 through 999, block 1 represents blocks 1000 - 1999, etc. Since the range of ints is finite, we know that the number of blocks needed is finite.H3#@35.	You have an array with all the numbers from 1 to N, where N is at most 32,000. The array may have duplicate entries and you do not know what N is. With only 4KB of memory available, how would you print all duplicate elements in the array? We have 4KB of memory which means we can address up to 8 * 4 * (2^10) bits. Note that 32* (2^10) bits is greater than 32000. We can create a bit vector with 32000 bits, where each bit represents one integer.CODE_START#START_SNIPPETboolean get(int pos) { 	int wordNumber = (pos >> 5); // divide by 32 	int bitNumber = (pos & 0x1F); // mod 32 	return (bitset[wordNumber] & (1 << bitNumber)) != 0; } void set(int pos) { 	int wordNumber = (pos >> 5); // divide by 32 	int bitNumber = (pos & 0x1F); // mod 32 	bitset[wordNumber] |= 1 << bitNumber; } CODE_END#H3#@36.	If you were designing a web crawler, how would you avoid getting into infinite loops? Page: www.google.com and www.google.com?query could be same. So, url should not be unique attribute for page.CODE_START#START_SNIPPET1.	Open page and create signature of page based on some specific content2.	Query database if something is similar to it then put that record back to DB with low priority3. 	If not then crawl page and put children to db back.4.	Perform DFS to traverse through DB records.CODE_END#H3#@37.	You are given two sorted arrays, A and B, and A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order. Start from end of A and B. Shift the largest element at the end of buffer of A.CODE_START#START_SNIPPETpublic static void merge(int[] a, int[] b, int n, int m) { 	int k = m + n - 1; // Index of last location of array b 	int i = n - 1; // Index of last element in array b 	int j = m - 1; // Index of last element in array a 	// Start comparing from the last element and merge a and b while (i >= 0 && j >= 0) { 	if (a[i] > b[j]) { 		a[k--] = a[i--]; 	} else { 		a[k--] = b[j--]; 	} 	} 	while (j >= 0) { 		a[k--] = b[j--]; 	} } CODE_END#H3#@38.	Complexity of sorting algorithm.img#@http://infopulseukraine.com/Global/Blog/Timsort/img_timsort_1.pngH3#@39.	Quick Sortimg#@http://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gifCODE_START#START_SNIPPETint partition(int arr[], int left, int right){      int i = left, j = right;      int tmp;      int pivot = arr[(left + right) / 2];           while (i <= j) {            while (arr[i] < pivot)                  i++;            while (arr[j] > pivot)                  j--;            if (i <= j) {                  tmp = arr[i];                  arr[i] = arr[j];                  arr[j] = tmp;                  i++;                  j--;            }      };           return i;} void quickSort(int arr[], int left, int right) {      int index = partition(arr, left, right);      if (left < index - 1)            quickSort(arr, left, index - 1);      if (index < right)            quickSort(arr, index, right);}CODE_END#H3#@40.	Implement external sort.CODE_START#START_SNIPPETCODE_END#H3#@41.	Check Balanced Parentheses.CODE_START#START_SNIPPETdef isBalanced(expr): 	if len(expr)%2!=0:		return False 	opening=set('([{') 	match=set([ ('(',')'), ('[',']'), ('{','}') ]) 	stack=[] 		for char in expr: 		if char in opening: 			stack.append(char) 		else: if len(stack)==0: 			return False 		lastOpen=stack.pop() 		if (lastOpen, char) 			not in match: 			return False return len(stack)==0 CODE_END#H3#@42.	There is a building of 100 floors. If an egg drops from the Nth floor or above it will break. If it's dropped from any floor below, it will not break. You're given 2 eggs. Find N, while minimizing the number of drops for the worst case.H4#@Using The Binary Search MethodYour first instinct (especially if you are a programmer) may be to solve this problem using the binary search method. So, you think that maybe by dividing the “result set” in half each time you will be able to solve the problem and find the threshold floor for the eggs. In this case the “result set” is the floors in the building, so you start at floor 50 since that is half of 100.Let's say we do start at the 50th floor, then what should we do if the egg breaks? This means that the answer is somewhere between the first and 50th floor. And we would be left with only 1 more egg since we started with 2 eggs. Now if we are following the binary search method, it seems that the next step would be to try dropping the remaining egg from the 25th floor. But what if it breaks at the 25th floor? Then we really don't have an answer to the problem since we have not found the threshold floor for the eggs. Even if it doesn't break and we decide to go to the next floor (which would be half of 25 or 12.5, which is approximately 13), then if it breaks at the 13th floor then we would still not have an answer to the problem.Clearly the binary search method does not work for us here, because we only have 2 eggs. The binary search method would be good in a scenario where we have an infinite number of eggs, but we now have to change our strategy and find a better solution.H4#A new solutionSince we have to find the answer with 2 eggs then why not do something like this: we start by dropping one of the eggs on the 10th floor: if it doesn't break then we continue on to the 20th floor, then 30th, 40th… up to 100 in intervals of 10 until the first egg actually breaks. If the egg breaks on the 10th floor then we know that the threshold floor must be either the 10th floor or one of the floors below it – the egg will definitely break on any floor above the 10th floor, so we can eliminate all of the floors above the 10th.If the egg breaks on the 10th floor…So, the answer must be between floors 1 through 10. We can take the 2nd egg and drop it from the first floor. If it does not break on the first floor, but it does break on the 2nd floor, then we know that the 2nd floor is the “threshold” floor. And if it doesn't break on any of the floors between 2-8, then we just continue up until the 9th floor, and if it does not break on the 9th floor then we know that the 11th floor is our threshold floor. This will take a maximum of 10 drops to figure out the threshold floor in this instance.What about the worst case solution? Well, the worst case using this method occurs when the threshold floor is the 100th floor. This means that we use 10 drops to get to the 100th floor, because we start from the 10th floor and go up in intervals of 10 up to the 100th floor, and the first egg will break on the 100th floor. And then we use another 9 drops with the 2nd egg because we have to test floors 90-99 to see if the threshold floor is somewhere in that range. This gives us a total of 19 drops, which is the absolute worst case scenario using this method.H4#Use the linear search method for this brainteaserThe simple search method we used above is called a linear search – which is simply a sequential search to find a particular value in a list of elements. In this case, the list of elements are floors in a building, and the value we are searching for is the threshold floor in that building for the eggs.It should be clear to you now that a linear search is indeed necessary with the 2nd egg because we can not risk breaking the 2nd egg before we even find the answer – remember we only have 2 identical eggs and we must find the answer with only 2 eggs. This means that we have some freedom with the 1st egg, and that we can do some interesting work with it. So, now the question is can we improve upon the 19 drops used in the worst case scenario with our approach above?H4#2 Eggs 100 Floors Puzzle SolutionWe want to minimize the number of drops for the worst case, while still using an approach that works well for other scenarios. So, how can we do this? Well, we should rephrase that question and ask ourselves what is really holding us back here? The main reason why it takes such a large number of drops in the worst case with our approach above (19 drops) is because in order to test out the higher floors of the building we have to start at the lower floors of the building, and at that point we have already used a large number of drops just to get to that point.What we should try to get with our next approach is to try to reduce the worst case scenario by trying to make all possible scenarios take the same number of drops.What if we tried to reduce the number of drops that would be required with the linear search (with the 2nd egg) after we get to one of the higher floors? This way we counteract the fact that getting to the higher floor took so many drops, and if we use less drops for the linear search we are balancing out the worst case.Let's try to figure this out using some simple algebra. Suppose we drop an egg from floor x. If the egg breaks, then we would have to go through the previous x-1 floors one by one using a linear search.But, if the egg doesn't break, in our original algorithm we would go up x floors to find the next floor to test from. Why not just go up x-1 floors instead of x floors? This would save us 1 drop if we have to do a linear search with the 2nd egg whenever the first egg breaks – because we would be doing the linear search from floors x+1 to floor ( (x+1) + (x-1)) instead of floors x+1 to floor (x+1) + x. So, that is 1 less egg drop. This means that the next floor that should be attempted to drop from is x + (x-1) if the egg does not break from floor x. And by the same reasoning the floor after that would be x + (x-1) + (x-2) if the egg does not break on floor x + (x-1).This would go on to form a series that looks like this:BOX_START#START_BOX_CONTENTx + (x-1) + (x-2) + (x-3) + ... + 1BOX_END#The series above is what's called a triangular series which is equal to x(x+1)/2. Because there are 100 floors in the building, we set the sum equal to 100 to solve for x:BOX_START#START_BOX_CONTENTx(x+1)/2 = 100BOX_END#When the sum of the series above equals 100, we get x = 13.651, which rounds up to 14. This means that we should start from floor 14 (which is our x) and then move up x-1 (13) floors to floor 27 if the egg doesn't break and then move up x-2 (12) floors to floor 39 and so on if the egg still does not break.This is the number of drops required as we move up the floors in the building: Drop 	 Floor #1	14#2	27#3	39#4	50#5	60#6	69#7	77#8	84#9	90#10	95#11	99#12	1002 Eggs 100 Floors Worst Case SolutionThe solution for the worst case in this scenario occurs when the threshold floor is floor number 14 – because we will drop the first egg on floor 14, and it will break. Then we have to test floors 1-13 with the 2nd egg to see where the egg breaks again, and the egg will not break on any of those floors. But since the egg broke on the floor 14, we can conclude that the threshold floor is floor number 14.H3#@43.	There are one hundred closed lockers in a hallway. A man begins by opening all one hundred lockers. Next, he closes every second locker. Then he goes to every third locker and closes it if it is open or opens it if it is closed (e.g., he toggles every third locker). After his one hundredth pass in the hallway, in which he toggles only locker number one hundred, how many lockers are open?A door n is toggled once for each factor of n, including itself and 1. That is, door 15 is toggled on round 1, 3, 5, and 15.Question: When would a door be left open?Answer: A door is left open if the number of factors (x) is odd. You can think about this by pairing factors off as an open and a close. If there's one remaining, the door will be open.Question: When would x be odd?Answer: x is odd if n is a perfect square. Here's why: pair n's factors by their complements. For example, if n is 36, the factors are (1, 36), (2, 18), (3, 12), (4, 9), (6, 6). Note that (6, 6) only contributes 1 factor, thus giving n an odd number of factors.Question: How many perfect squares are there?Answer: There are 10 perfect squares. You could count them (1, 4, 9, 16, 25, 36, 49, 64, 81, 100), or you could simply realize that you can take the numbers 1 through 10 and square them (1*1, 2*2, 3*3, ..., 10*10).Therefore, there are 10 lockers open.H3#@44.	Given a matrix in which each row and each column is sorted, write a method to find an element in it. 1.	Rows are sorted left to right in ascending order. Columns are sorted top to bottom in ascending order. 2.	Matrix is of size MxN. This algorithm works by elimination. Every move to the left (--col) eliminates all the elements below the current cell in that column. Likewise, every move down eliminates all the elements to the left of the cell in that row.CODE_START#START_SNIPPETboolean FindElem(int[][] mat, int elem, int M, int N) { 	int row = 0;	int col = N-1;	while (row < M && col >= 0) { 		if (mat[row][col] == elem) { 			return true; 		} else if (mat[row][col] > elem) { 			col--;		} else { 			row++; 		} 	} 	return false; } CODE_END#H3#@45.	How to find if two lines intersect in Cartesian plane.On a Cartesian plane, if two lines do not intersect, they must be parallel with each other. Hence, their slopes must be the same. If their slopes are different, they would intersect. A line is represented as ax+by+c=0 on a Cartesian plane and the slope is given by -a/b Therefore if -a1/b1 != -a2/b2 for two lines, they will intersect.CODE_START#START_SNIPPETpublic class Line {    static final double epsilon = 0.000001;    public double slope;    public double yintercept;     public Line(double s, double y) {        slope = s;        yintercept = y;    }     public boolean intersect(Line line2) {        return Math.abs(slope - line2.slope) > epsilon                || Math.abs(yintercept - line2.yintercept) < epsilon;    }}CODE_END#1.	Two lines can be the same. In that case, we assume they intersects (overlap).2.	We need to consider the floating system in a computer. Never use == to compare two floating numbers.H3#@46.	Traverse directed graph.img#@http://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Directed_acyclic_graph.png/180px-Directed_acyclic_graph.pngH4#@Algorithm: Topological SortingCODE_START#START_SNIPPETL <- Empty list that will contain the sorted elementsS <- Set of all nodes with no incoming edgeswhile S is non-empty do    remove a node n from S    add n to tail of L    for each node m with an edge e from n to m do        remove edge e from the graph        if m has no other incoming edges then            insert m into Sif graph has edges then    return error (graph has at least one cycle)else     return L (a topologically sorted order)CODE_END#a#@https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=10&cad=rja&uact=8&ved=0CHsQFjAJ&url=http%3A%2F%2Fcs.fit.edu%2F~dmitra%2FAlgorithms%2Flectures%2FGRAPH.doc&ei=YmwhU5rdJ4j4oATYsoGoDw&usg=AFQjCNHw8a308UUAGVFGukEtUoaME_86ag&sig2=VsWhMlNA4Dndxj-oCEyHxw&bvm=bv.62922401,d.cGU#@Click here to know about GraphH3#@47.	Find a line to cut two squares in half.Line should pass through center of both square.CODE_START#START_SNIPPET    private double topLeftX;    private double topLeftY;    private double edge;     public Square(double topLeftX, double topLeftY, double edge) {        super();        this.topLeftX = topLeftX;        this.topLeftY = topLeftY;        this.edge = edge;    }     Pair<Double> getCenter() {        return new Pair<Double>(topLeftX + edge / 2, topLeftY - edge / 2);    }} public class Line {    private double slope;    private double intercept;     public Line(double slope, double intercept) {        super();        this.slope = slope;        this.intercept = intercept;    }} public static Line getLine(Square a, Square b) {    Pair<Double> centerA = a.getCenter();    Pair<Double> centerB = b.getCenter();     if (centerA.equals(centerB)) {        return new Line(centerA.getY() / centerA.getX(), 0);    } else {        double slope = (centerB.getY() - centerA.getY())                / (centerB.getX() - centerA.getX());        double intercept = (centerB.getX() * centerA.getY() - centerA                .getX() * centerB.getY())                / (centerB.getX() - centerA.getX());        return new Line(slope, intercept);    }}CODE_END#H3#@47.	Clone graph.	   1      / \     /   \    0 --- 2         / \         \_/CODE_START#START_SNIPPET/** * Definition for undirected graph. * struct UndirectedGraphNode { *     int label; *     vector<UndirectedGraphNode *> neighbors; *     UndirectedGraphNode(int x) : label(x) {}; * }; */class Solution {public:    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {        map<UndirectedGraphNode*, UndirectedGraphNode*> chkset;        queue<UndirectedGraphNode*> chk;        if (!node) return NULL;        chk.push(node);        UndirectedGraphNode *newNode = new UndirectedGraphNode(node->label);        chkset[node] = newNode;        while (!chk.empty()) {            UndirectedGraphNode *curr = chk.front();            chk.pop();            for (int i = 0; i < curr->neighbors.size(); ++i) {                UndirectedGraphNode *neighbor = curr->neighbors[i];                if (chkset.count(neighbor)) {                    chkset[curr]->neighbors.push_back(chkset[neighbor]);                } else {                    UndirectedGraphNode *tmp = new UndirectedGraphNode(neighbor->label);                    chkset[curr]->neighbors.push_back(tmp);                    chkset[neighbor] = tmp;                    chk.push(neighbor);                }            }        }        return newNode;    }};CODE_END#H3#@48.	Dijkstra's algorithmCODE_START#START_SNIPPET function Dijkstra(Graph, source):      for each vertex v in Graph:                                // Initializations          dist[v]  := infinity ;                                  // Unknown distance function from                                                                  // source to v          previous[v]  := undefined ;                             // Previous node in optimal path      end for                                                    // from source            dist[source]  := 0 ;                                        // Distance from source to source      Q := the set of all nodes in Graph ;                       // All nodes in the graph are                                                                 // unoptimized – thus are in Q      while Q is not empty:                                      // The main loop          u := vertex in Q with smallest distance in dist[] ;    // Source node in first case          remove u from Q ;          if dist[u] = infinity:              break ;                                            // all remaining vertices are          end if                                                 // inaccessible from source                    for each neighbor v of u:                              // where v has not yet been                                                                  // removed from Q.              alt := dist[u] + dist_between(u, v) ;              if alt < dist[v]:                                  // Relax (u,v,a)                  dist[v]  := alt ;                  previous[v]  := u ;                  decrease-key v in Q;                           // Reorder v in the Queue              end if          end for      end while      return dist;end functionCODE_END#H3#@49.	Write a method which finds the maximum of two numbers You should not use if-else or any other comparison operator.CODE_START#START_SNIPPETgetMax(int a, int b) { int c = a - b;int k = (c >> 31) & 0x1; int max = a - k * c; return max; CODE_END#H3#@50.	Add two number without + operator.CODE_START#START_SNIPPETint Add(int x, int y){    // Iterate till there is no carry      while (y != 0)    {        // carry now contains common set bits of x and y        int carry = x & y;           // Sum of bits of x and y where at least one of the bits is not set        x = x ^ y;          // Carry is shifted by one so that adding it to x gives the required sum        y = carry << 1;    }    return x;}CODE_END#H3#@51.	Give a result of two integer array: Given two arrays a1={1,2,3,4} and a2={5,6,7,8}, add the two array and return a new array n={6,9,1,2}CODE_START#START_SNIPPETpublic static int[] addArray(int[] ar1, int ar2[]){int counter1=ar1.length-1;int counter2=ar2.length-1;int counter3= (counter1>counter2?counter1:counter2 )+1;int[] ar3 = new int[counter3+1];int carry=0;while(counter3>-1){if(counter1>=0) carry+=ar1[counter1--];if(counter2>=0) carry+=ar2[counter2--];ar3[counter3--]=carry%10;carry /= 10;}return ar3;}CODE_END#H3#@52.	Find minimal number of combination: For example: the minimal number of coins to make change for 15 out of a set of coins with value 1, 3, 9. is 3.We can choose two coins with value 3 and a coin with value 9. The number of coins for other choices should be greater than 3.b#@i.e.: 3 -> f(3 - MaxCurrencyBelow(3))+1 -> f(3 - 3) + 1 => f(0)+ 1 =>16 -> f(6 - MaxCurrencyBelow(6))+1 -> f(6 - 3) + 1 => f(3)+ 1 => 215 -> f(15 - MaxCurrencyBelow(15))+1 -> f(15 - 9) + 1 => f(6)+ 1 => 324 -> f(24 - MaxCurrencyBelow(24))+1 -> f(24 - 9) + 1 => f(15)+ 1 => 4CODE_START#START_SNIPPETint GetMinCount(int total, int* coins, int length){    int* counts = new int[total + 1];    counts[0] = 0;       const int MAX = 0x7FFFFFFF;    for(int i = 1; i <= total; ++ i)    {        int count = MAX;        for(int j = 0; j < length; ++ j)        {            if(i - coins[j] >= 0 && count > counts[i - coins[j]])                count = counts[i - coins[j]];        }        if(count < MAX)            counts[i] = count + 1;        else            counts[i] = MAX;    }    int minCount = counts[total];    delete[] counts;    return minCount;}CODE_END#H3#@53.	Edit Distance.The words `computer' and `commuter' are very similar, and a change of just one letter, p->m will change the first word into the second. The word `sport' can be changed into `sort' by the deletion of the `p', or equivalently, `sort' can be changed into `sport' by the insertion of `p'.The edit distance of two strings, s1 and s2, is defined as the minimum number of point mutations required to change s1 into s2, where a point mutation is one of:1. change a letter,2. insert a letter or3. delete a letterimg#@http://www.quretec.com/u/vilo/edu/2005-06/Text_Algorithms/L5_Edit/Edit_dist_diagonal_def.pngCODE_START#START_SNIPPETint getEditDistance(char* str1, char* str2, int** distances, int len1, int len2){    for(int i = 0; i < len2 + 1; ++ i)        distances[i][0] = i;    for(int j = 0; j < len1 + 1; ++ j)        distances[0][j] = j;    for(int i = 1; i < len2 + 1; ++ i)    {        for(int j = 1; j < len1 + 1; ++ j)        {            if(str1[j - 1] == str2[i - 1])                distances[i][j] = distances[i - 1][j - 1];            else            {                int deletion = distances[i][j - 1] + 1;                int insertion = distances[i - 1][j] + 1;                int substitution = distances[i - 1][j - 1] + 1;                distances[i][j] = min(deletion, insertion, substitution);            }        }    }    return distances[len2][len1];}CODE_END#H3#@54.	Dynamic Programming on Stolen Values.There are n houses built in a line, each of which contains some value in it. A thief is going to steal the maximal value in these houses, but he cannot steal in two adjacent houses because the owner of a stolen house will tell his two neighbors on the left and right side. What is the maximal stolen value?For example, if there are four houses with values {6, 1, 2, 7}, the maximal stolen value is 13 when the first and fourth houses are stolen.We will maintain two values at each element.1. If we follow alternate sequence for current element. 2. If we follow alternate sequence for next element. Let me simplify above confusing statement.	6		1		2			7				9	6	    6	   6,8(6+2)     8,13(6+7)       13,17(8+9)CODE_START#START_SNIPPETint maxStolenValue(const vector<int>& values){    int length = values.size();    if(length == 0)        return 0;    int value1 = values[0];    if(length == 1)        return value1;    int value2 = max<int>(values[0], values[1]);    if(length == 2)        return value2;    int value;    for(int i = 2; i < length; ++i)    {        value = max<int>(value2, value1 + values[i]);        value1 = value2;        value2 = value;    }    return value;}CODE_END#H3#@54.	A man is running up a staircase with n steps, and can go either 1 steps, 2 steps, or 3 steps at a time. Now write a program to count how many possible ways the child can run the stairs.CODE_START#START_SNIPPETpublic static int countDP(int n, int[] map) { if (n<0)   return 0; else if (n==0)   return 1; else if (map[n]>-1)   return map[n]; else {    map[n] = countDP(n-1, map) + countDP(n-2, map) + countDP(n-3, map);    return map[n]; } }CODE_END#Okay, here is what the code does. `if (n<0)`    `return 0;`If there aren't enough steps remaining, then don't count it. For instance, if there are two steps remaining, but the user is trying to take three steps, then it does not count as a possible combination.else if (n==0)  return 1;If the number of steps remaining matches the number of available steps the user is trying to take, it is a possible combination. So, return a 1 because this is a possible combination and should be added to the total number of valid combinations.else if (map[n]>-1)  return map[n];Here is the dynamic programming part. Assume that the all the values in the array had a value of -1. So, if the number is greater than -1, it has already been solved for, so return the total number of combinations from step number n instead of resolving it.`map[n] = countDP(n-1, map) + countDP(n-2, map) + countDP(n-3, map);`return map[n]; }Finally, this part solves the code. The number of possible combinations is equal to the number of possible combinations the user can get if he takes 1 step + the number of possible combinations the user can get if he takes 2 steps + the number of possible combinations the user can get if he takes three steps.An example, suppose there are 5 stepsBOX_START#START_BOX_CONTENT/The number of solutions from the fifth stepcountDp(5) = countDp(4)+countDp(3)+countDp(2);//Number of solutions from the fourth stepcountDP(4) = countDp(3)+countDp(2)+countDp(1);//Number of solutions from the third stepcountDp(3) = countDp(2)+countDp(1)+countDp(0);//Number of solutions from the second stepcountDp(2) = countDp(1)+countDp(0)+countDp(-1);//Number of solutions from the first stepcountDp(1) = countDp(0) + countDp(-1)+countDp(-2);//Finally, base casecountDp(0) = 1;countDp(-1)= 0;countDp(-2)= 0;countDp(1) = 1+0+0 = 1;countDp(2) = 1+1+0 = 2;  //Dynamic programming: did not have to resolve for countDp(1), instead looked up the value in map[1]countDp(3) = 2+1+1 = 4;  //Dynamic programming, did not have to solve for countDp(1), countDp(2), instead looked up value in map[1] and map[2]countDp(4) = 4+2+1=7 //Dynamic programming, did not have to solve for CountDp(3),CountDp(2), CountDp(1), just looked them up in map[3],map[2],map[1]countDp(5)=  2+4+7=13 //Dynamic programming, just used map[4]+map[3]+map[2]BOX_END#H3#@54.	Longest Increasing Subsequence.he longest increasing subsequence problem is a dynamic programming problem that calculates the length of a non-contiguous subsequence from a given sequence. For example, given the sequence: 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15A subsequence is 0,4,2,1,5. An increasing subsequence is 0,4,10,14,15. The question is to find the length of the longest increasing subsequence, which has size 6 (0, 2, 6, 9, 13, 15). Note that the sequence might not be unique, but you need to find the length of the longest subsequence. i.e.:0,8,4,12,21.	Every element will get default weight = 1.2. It can also gets additional weight from its latest previous elements if they are smaller and who has highest value then it. It starts from 1st element.0=18=w(0)+1=1+1=24=w(0)+1=1+1=212=w(4)+1=32=w(0)+1=2CODE_START#START_SNIPPETpublic static int increasingSubsequence(int[]seq){    int[]L=new int[seq.length];    L[0]=1;    for(int i=1;i<L.length;i++){      int maxn=0;      for(int j=0;j<i;j++){        if(seq[j]<seq[i]&&L[j]>maxn){          maxn=L[j];        }      }      L[i]=maxn+1;    }    int maxi=0;    for(int i=0;i<L.length;i++){      if(L[i]>maxi){        maxi=L[i];      }    }    return(maxi);}CODE_END#H3#@54.	Find longest common substringi.e.:XYZABC YZAL[0,0]=0,[0,1]=0,l[0,2]=0L[1,0]=1,[1,1]=0,l[1,2]=0L[2,0]=0,[2,1]=L[1,0]+1=2,l[0,2]=0CODE_START#START_SNIPPETfunction LCSubstr(S[1..m], T[1..n])    L := array(1..m, 1..n)    z := 0    ret := {}    for i := 1..m        for j := 1..n            if S[i] == T[j]                if i == 1 or j == 1                    L[i,j] := 1                else                    L[i,j] := L[i-1,j-1] + 1                if L[i,j] > z                    z := L[i,j]                    ret := {S[i-z+1..i]}                elif L[i,j] == z                    ret := ret ∪ {S[i-z+1..i]}            else                 L[i,j] := 0    return retCODE_END#H3#@55.	Stack with Function min(). pop(), push(), min() should have complexity o(1).Supposing that we are going to push a number value into a stack with minimum number min. If value is greater than or equal to the min, it is pushed directly into data stack. If it is less than min, we push 2*value -min, and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top) is greater than or equal to min. Otherwise the number top is not the real pushed number. The real pushed number is stored is min. After the current minimum number is popped, we need to restore the previous minimum number, which is 2*min-top.H3#@56.	Given an array of numbers, find out if 3 of them add up to 0.CODE_START#START_SNIPPETSort the array // O(nlogn)for each i from 1 to len(array) - 1  iter = i + 1  reviter = len(array) - 1  while iter < reviter    tmp = array[iter] + array[reviter] + array[i]    if  tmp > 0       reviter--    else if tmp < 0       iter++    else       return truereturn falseCODE_END#H3#@57.	Diameter of Binary Tree or longest path of a Binary tree.There are three cases to consider when trying to find the longest path between two nodes in a binary tree (diameter):The longest path passes through the root,The longest path is entirely contained in the left sub-tree,The longest path is entirely contained in the right sub-tree.The longest path through the root is simply the sum of the heights of the left and right sub-trees + 1 (for the root node), and the other two can be found recursively:CODE_START#START_SNIPPETpublic static int getDiameter(BinaryTreeNode root) {            if (root == null)        return 0;    int rootDiameter = getHeight(root.getLeft()) + getHeight(root.getRight()) + 1;    int leftDiameter = getDiameter(root.getLeft());    int rightDiameter = getDiameter(root.getRight());    return Math.max(rootDiameter, Math.max(leftDiameter, rightDiameter));}public static int getHeight(BinaryTreeNode root) {    if (root == null)        return 0;    return Math.max(getHeight(root.getLeft()), getHeight(root.getRight())) + 1;}CODE_END#H3#@58.	Transform a binary tree to a left child right sibling tree?CODE_START#START_SNIPPETBST * siblingsTransform(BST *root) { if(root == NULL) return NULL; siblingsTransform(root->left); siblingsTransform(root->right); if(root->left !=NULL) { root->left ->right = root->right; root->right = NULL; } else { root->left = root->right; } return root; }CODE_END#H3#@59.	how to merge two BST's efficiently?CODE_START#START_SNIPPETH4#@Flattening a BST into a sorted list is O(N)1. It's just "in-order" iteration on the whole tree.2. Doing it for both is O(n1+n2)H4#@Merging two sorted lists is into one sorted list is O(n1+n2).1. Keep pointers to the heads of both lists2. Pick the smaller head and advance its pointer3. This is how the merge of merge-sort worksH4#@Creating a perfectly balanced BST from a sorted list is O(N)1. The value at the middle would be the root, and recurse.2. In our case the sorted list is of size n1+n2. so O(n1+n2)3. The resulting tree would be the conceptual BST of binary searching the listThree steps of O(n1+n2) result in O(n1+n2)For n1 and n2 of the same order of magnitude, that's better than O(n1 * log(n2))CODE_END#H3#@60.	Longest palindromeCODE_START#START_SNIPPETstring expandAroundCenter(string s, int c1, int c2) {  int l = c1, r = c2;  int n = s.length();  while (l >= 0 && r <= n-1 && s[l] == s[r]) {    l--;    r++;  }  return s.substr(l+1, r-l-1);} string longestPalindromeSimple(string s) {  int n = s.length();  if (n == 0) return "";  string longest = s.substr(0, 1);  // a single char itself is a palindrome  for (int i = 0; i < n-1; i++) {    string p1 = expandAroundCenter(s, i, i);    if (p1.length() > longest.length())      longest = p1;     string p2 = expandAroundCenter(s, i, i+1);    if (p2.length() > longest.length())      longest = p2;  }  return longest;}CODE_END#H3#@61.	Find square root.CODE_START#START_SNIPPET	# using Babylonian method, if N is number and x is estimate, replace x by (x+N/x)/2;import math;def main():        # N will contain the number whose square root needs to be found.        N=466;        # initial estimate of square root        x=N/2.0;        x += 0.0;        precision = 0.000003;        while True:                if math.fabs(x*x-N) < precision: break;                x = (x+N/x)/2        print "Given Number = ",N;        print "Approx Square Root = ", x;        print "Square of approx square root = ", x*x;main();CODE_END#	H3#@62.	Find a line which passes the most number of points.We have a bunch of line segments, represented as a slope and y-intercept, and we want to find the most common slope and y-intercept. How can we find the most common one? This is really no different than the old "find the most common number in a list of numbers" problem. We just iterate through the lines segments and use a hash table to count the number of times we've seen each line.CODE_START#START_SNIPPETpublic static Line findBestLine(GraphPoint[] points) {    Line bestLine = null;    HashMap<Line, Integer> line_count = new HashMap<Line, Integer>();    for (int i = 0; i < points.length; i++) {        for (int j = i + 1; j < points.length; j++) {            Line line = new Line(points[i], points[j]);            if (!line_count.containsKey(line)) {                line_count.put(line, 0);            }            line_count.put(line, line_count.get(line) + 1);            if (bestLine == null                    || line_count.get(line) > line_count.get(bestLine)) {                bestLine = line;            }        }    }    return bestLine;} public class Line {    private static double epsilon = .0001;    public double slope;    public double intercept;    private boolean infinite_slope = false;     public Line(GraphPoint p, GraphPoint q) {        if (Math.abs(p.x - q.x) > epsilon) { // if x's are different            slope = (p.y - q.y) / (p.x - q.x); // compute slope            intercept = p.y - slope * p.x; // y intercept from y=mx+b        } else {            infinite_slope = true;            intercept = p.x; // x-intercept, since slope is infinite        }    }     public boolean isEqual(double a, double b) {        return (Math.abs(a - b) < epsilon);    }     @Override    public int hashCode() {        int sl = (int) (slope * 1000);        int in = (int) (intercept * 1000);        return sl | in;    }     @Override    public boolean equals(Object o) {        Line l = (Line) o;        if (isEqual(l.slope, slope) && isEqual(l.intercept, intercept)                && (infinite_slope == l.infinite_slope)) {            return true;        }        return false;    }}CODE_END#H3#@55.	Implement tri tree.CODE_START#START_SNIPPETpublic class Trie{ private Node root;  public Trie(){  root = new Node(' ');  }  public Node subNode(char c){  if(child!=null){   for(Node eachChild:child){    if(eachChild.content == c){     return eachChild;    }   }  }  return null; }  public void insert(String s){  Node current = root;   if(s.length()==0) //For an empty character   current.marker=true;  for(int i=0;i<s.length();i++){   Node child = current.subNode(s.charAt(i));   if(child!=null){     current = child;   }   else{    current.child.add(new Node(s.charAt(i)));    current = current.subNode(s.charAt(i));   }   // Set marker to indicate end of the word   if(i==s.length()-1)    current.marker = true;  }  }  public boolean search(String s){  Node current = root;  while(current != null){   for(int i=0;i<s.length();i++){        if(current.subNode(s.charAt(i)) == null)     return false;    else     current = current.subNode(s.charAt(i));   }   /*     * This means that a string exists, but make sure its    * a word by checking its 'marker' flag    */   if (current.marker == true)    return true;   else    return false;  }  return false;  }}CODE_END#