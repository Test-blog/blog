H3#@1. How does the Object Oriented approach improve software development? DCThe key benefits are:a. Re-use of previous work: using implementation inheritance and object composition.b. Real mapping to the problem domain: Objects map to real world and represent vehicles, customers,products etc: with encapsulation.c. Modular Architecture: Objects, systems, frameworks etc are the building blocks of larger systems.The increased quality and reduced development time are the by-products of the key benefits discussed above.If 90% of the new application consists of proven existing components then only the remaining 10% of the codehave to be tested from scratch.H3#@2. Why there are some interfaces with no defined methods (i.e. marker interfaces) in Java? The interfaces with no defined methods act like markers. They just tell the compiler that the objects of the classesimplementing the interfaces with no defined methods need to be treated differently. Example Serializable , Cloneable etc.H3#@3. What is the main difference between an ArrayList and a Vector? What is the main difference between Hashmap and Hashtable? Vector / Hashtable ArrayList / HashmapOriginal classes before the introduction of Collections API. Vector & Hashtable are synchronized. Any method that touches their contents is thread-safe.So if you don’t need a thread safe collection, use the ArrayList or Hashmap. Why pay the price of synchronization unnecessarily at the expense of performance degradation.So which is better? As a general rule, prefer ArrayList/Hashmap to Vector/Hashtable. If your application is a multithreaded application and at least one of the threads either adds or deletes an entry into the collection then use new Java collection API‘s external synchronization facility as shown below to temporarily synchronize your collections as needed: Map myMap = Collections.synchronizedMap (myMap);List myList = Collections.synchronizedList (myList);Java arrays are even faster than using an ArrayList/Vector and perhaps therefore may be preferable.ArrayList/Vector internally uses an array with some convenient methods like add(..), remove(…) etc.H3#@4. Explain the Java Collection framework?The key interfaces used by the collection framework are List, Set and Map. The List and Set extends theCollection interface. Should not confuse the Collection interface with the Collections class which is a utility class.A Set is a collection with unique elements and prevents duplication within the collection. HashSet and TreeSetare implementations of a Set interface. A List is a collection with an ordered sequence of elements and maycontain duplicates. ArrayList, LinkedList and Vector are implementations of a List interface.The Collection API also supports maps, but within a hierarchy distinct from the Collection interface. A Map is anobject that maps keys to values, where the list of keys is itself a collection object. A map can contain duplicatevalues, but the keys in a map must be distinct. HashMap, TreeMap and Hashtable are implementations of a Mapinterface.How to implement collection ordering? SortedSet and SortedMap interfaces maintain sorted order. Theclasses, which implement the Comparable interface, impose natural order. For classes that don’t implementcomparable interface, or when one needs even more control over ordering based on multiple attributes, aComparator interface should be used.Design pattern: What is an Iterator? An Iterator is a use once object to access the objects stored in a collection.Iterator design pattern (aka Cursor) is used, which is a behavioural design pattern that provides a way to accesselements of a collection sequentially without exposing its internal representation.H3#@What are the benefits of the Java collection framework? Collection framework provides flexibility,performance, and robustness.a. Polymorphic algorithms – sorting, shuffling, reversing, binary search etc.b. Set algebra - such as finding subsets, intersections, and unions between objects.c. Performance - collections have much better performance compared to the older Vector and Hashtableclasses with the elimination of synchronization overheads.d. Thread-safety - when synchronization is required, wrapper implementations are provided for temporarilysynchronizing existing collection objects.e. Immutability - when immutability is required wrapper implementations are provided for making a collectionimmutable.f. Extensibility - interfaces and abstract classes provide an excellent starting point for adding functionality andfeatures to create specialized object collections.H3#@5. What are some of the best practices relating to Java collection?Use ArrayLists, HashMap etc as opposed to Vector, Hashtable etc, where possible to avoid anysynchronization overhead. Even better is to use just arrays where possible. If multiple threads concurrentlyaccess a collection and at least one of the threads either adds or deletes an entry into the collection,then the collection must be externally synchronized. This is achieved by:BOX_START#START_BOX_CONTENTMap myMap = Collections.synchronizedMap (myMap);BOX_END#Set the initial capacity of a collection appropriately (e.g. ArrayList, HashMap etc). This is because collectionclasses like ArrayList, HashMap etc must grow periodically to accommodate new elements. But if you have avery large array, and you know the size in advance then you can speed things up by setting the initial sizeappropriately.b#@For example: HashMaps/Hashtables need to be created with sufficiently large capacity to minimiserehashing (which happens every time the table grows). HashMap has two parameters initial capacity andload factor that affect its performance and space requirements. Higher load factor values (default load factorof 0.75 provides a good trade off between performance and space) will reduce the space cost but willincrease the lookup cost of myMap.get(…) and myMap.put(…) methods. When the number of entries in theHashMap exceeds the current capacity * loadfactor then the capacity of the HasMap is roughly doubled bycalling the rehash function. It is also very important not to set the initial capacity too high or load factor toolow if iteration performance or reduction in space is important.b#@a. Program in terms of interface not implementation: For example you might decide a LinkedList is the bestchoice for some application, but then later decide ArrayList might be a better choice for performance reason.BOX_START#START_BOX_CONTENTUse:List list = new ArrayList(100); //program in terms of interface & set the initial capacity.Instead of:ArrayList list = new ArrayList();BOX_END#b#@Avoid storing unrelated or different types of objects into same collection: This is analogous to storingitems in pigeonholes without any labelling. To store items use value objects or data objects (as oppose tostoring every attribute in an ArrayList or HashMap). Provide wrapper classes around your collection APIclasses like ArrayList, Hashmap etc as shown in better approach column. Also where applicable considerusing composite design pattern, where an object may represent a single object or a collection of objects.Refer Q52 in Java section for UML diagram of a composite design patternH3#@6. What is serialization? How would you exclude a field of a class from serialization or what is a transient variable? What is the common use?Serialization is a process of reading or writing an object. It is a process of saving an object’s state to a sequence ofbytes, as well as a process of rebuilding those bytes back into a live object at some future time. An object ismarked serializable by implementing the java.io.Serializable interface, which is only a marker interface -- it simplyallows the serialization mechanism to verify that the class can be persisted, typically to a file.b#@Transient variables cannot be serialized. The fields marked transient in a serializable object will not betransmitted in the byte stream. An example would be a file handle or a database connection. Such objects are onlymeaningful locally. So they should be marked as transient in a serializable class.b#@Serialization can adversely affect performance since it:a. Depends on reflection.b. Has an incredibly verbose data format.c. Is very easy to send surplus data.b#@bo#@When to use serialization? Do not use serialization if you do not have to. A common use of serialization is to useit to send an object over the network or if the state of an object needs to be persisted to a flat file or a database.H3#@7. The New I/O (NIO): more scalable and better performanceJava has long been not suited for developing programs that perform a lot of I/O operations. Furthermore,commonly needed tasks such as file locking, non-blocking and asynchronous I/O operations and ability to map fileto memory were not available. Non-blocking I/O operations were achieved through work around such asmultithreading or using JNI. The New I/O API (aka NIO) in J2SE 1.4 has changed this situation.A server’s ability to handle several client requests effectively depends on how it uses I/O streams. When a serverhas to handle hundreds of clients simultaneously, it must be able to use I/O services concurrently. One way tocater for this scenario in Java is to use threads but having almost one-to-one ratio of threads (100 clients will have100 threads) is prone to enormous thread overhead and can result in performance and scalability problemsdue to consumption of memory stacks and CPU context switching. To overcome this problem, a new set ofnon-blocking I/O classes have been introduced to the Java platform in java.nio package. The non-blocking I/Omechanism is built around Selectors and Channels. Channels, Buffers and Selectors are the core of the NIO.A Channel class represents a bi-directional communication channel (similar to InputStrean and OutputStream)between datasources such as a socket, a file, or an application component, which is capable of performing one ormore I/O operations such as reading or writing. Channels can be non-blocking, which means, no I/O operation willwait for data to be read or written to the network. The good thing about NIO channels is that they can beasynchronously interrupted and closed. So if a thread is blocked in an I/O operation on a channel, another threadcan interrupt that blocked thread.b#@Buffers hold data. Channels can fill and drain Buffers. Buffers replace the need for you to do your own buffermanagement using byte arrays. There are different types of Buffers like ByteBuffer, CharBuffer, DoubleBuffer, etc.A Selector class is responsible for multiplexing (combining multiple streams into a single stream) by allowing asingle thread to service multiple channels. Each Channel registers events with a Selector. When events arrivefrom clients, the Selector demultiplexes (separating a single stream into multiple streams) them and dispatchesthe events to corresponding Channels. To achieve non-blocking I/O a Channel class must work in conjunction witha Selector class.b#@Design pattern: NIO uses a reactor design pattern, which demultiplexes events (separating single stream intomultiple streams) and dispatches them to registered object handlers. The reactor pattern is similar to an observerpattern (aka publisher and subscriber design pattern), but an observer pattern handles only a single source ofevents (i.e. a single publisher with multiple subscribers) where a reactor pattern handles multiple event sources(i.e. multiple publishers with multiple subscribers). The intent of an observer pattern is to define a one-to-manydependency so that when one object (i.e. the publisher) changes its state, all its dependents (i.e. all itssubscribers) are notified and updated correspondingly.Another sought after functionality of NIO is its ability to map a file to memory. There is a specialized form of aBuffer known as MappedByteBuffer, which represents a buffer of bytes mapped to a file. To map a file toMappedByteBuffer, you must first get a channel for a file. Once you get a channel then you map it to a buffer andsubsequently you can access it like any other ByteBuffer. Once you map an input file to a CharBuffer, you can dopattern matching on the file contents. This is similar to running “grep” on a UNIX file system.b#@Another feature of NIO is its ability to lock and unlock files. Locks can be exclusive or shared and can be held on acontiguous portion of a file. But file locks are subject to the control of the underlying operating system.H8#@How can you improve Java I/O performance?Java applications that utilise Input/Output are excellent candidates for performance tuning. Profiling of Javaapplications that handle significant volumes of data will show significant time spent in I/O operations. This meanssubstantial gains can be had from I/O performance tuning. Therefore, I/O efficiency should be a high priority fordevelopers looking to optimally increase performance.The basic rules for speeding up I/O performance area. Minimise accessing the hard disk.b. Minimise accessing the underlying operating system.c. Minimise processing bytes and characters individually.Let us look at some of the techniques to improve I/O performance. d. Use buffering to minimise disk access and underlying operating system. As shown below, with bufferinglarge chunks of a file are read from a disk and then accessed a byte or character at a time.b#@CODE_START#START_SNIPPETtry{	File f = new File("myFile.txt");	FileInputStream fis = new FileInputStream(f);	int count = 0;	int b = ;	while((b = fis.read()) != -1){	if(b== '\n') {	count++;	}	}	// fis should be closed in a finally block.	fis.close() ;}catch(IOException io){}Note: fis.read() is a native method call to theunderlying system.CODE_END#b#@CODE_START#START_SNIPPETWith Buffering: yields better performancetry{	File f = new File("myFile.txt");	FileInputStream fis = new FileInputStream(f);	BufferedInputStream bis = new BufferedInputStream(fis);	int count = 0;	int b = ;	while((b = bis.read()) != -1){	if(b== '\n') {	count++;	}	}	//bis should be closed in a finally block.	bis.close() ;}catch(IOException io){}Note: bis.read() takes the next byte from the input buffer and onlyrarely access the underlying operating system.CODE_END#b#@Instead of reading a character or a byte at a time, the above code with buffering can be improved further byreading one line at a timeb#@Use the NIO package, if you are using JDK 1.4 or later, which uses performance-enhancing features likebuffers to hold data, memory mapping of files, non-blocking I/O operations etc.a. I/O performance can be improved by minimising the calls to the underlying operating systems. The Javaruntime itself cannot know the length of a file, querying the file system for isDirectory(), isFile(), exists() etcmust query the underlying operating system.b. Where applicable caching can be used to improve performance by reading in all the lines of a file into a Javacollection class like an ArrayList or a HashMap and subsequently access the data from an in-memorycollection instead of the disk.H3#@8. What is the main difference between shallow cloning and deep cloning of objects?The default behaviour of an object’s clone() method automatically yields a shallow copy. So to achieve a deepcopy the classes must be edited or adjusted.b#@bo#@Shallow copy: If a shallow copy is performed on obj-1 as shown in fig-2 then it is copied but its contained objectsare not. The contained objects Obj-1 and Obj-2 are affected by changes to cloned Obj-2. Java supports shallowcloning of objects by default when a class implements the java.lang.Cloneable interface.b#@bo#@Deep copy: If a deep copy is performed on obj-1 as shown in fig-3 then not only obj-1 has been copied but theobjects contained within it have been copied as well. Serialization can be used to achieve deep cloning. Deepcloning through serialization is faster to develop and easier to maintain but carries a performance overhead.H3#@9. What is the difference between final, finally and finalize() in Java?final - constant declaration. a. finally - handles exception. The finally block is optional and provides a mechanism to clean up regardless ofwhat happens within the try block (except System.exit(0) call). Use the finally block to close files or to releaseother system resources like database connections, statements etc. b. finalize() - method helps in garbage collection. A method that is invoked before an object is discarded by thegarbage collector, allowing it to clean up its state. Should not be used to release non-memory resources likefile handles, sockets, database connections etc because Java has only a finite number of these resources andyou do not know when the garbage collection is going to kick in to release these non-memory resourcesthrough the finalize() method.H3#@10. How does Java allocate stack and heap memory? Explain re-entrant, recursive and idempotentmethods/functions?Each time an object is created in Java it goes into the area of memory known as heap. The primitive variables likeint and double are allocated in the stack, if they are local method variables and in the heap if they are membervariables (i.e. fields of a class). In Java methods local variables are pushed into stack when a method is invokedand stack pointer is decremented when a method call is completed. In a multi-threaded application each threadwill have its own stack but will share the same heap. This is why care should be taken in your code to avoid anyconcurrent access issues in the heap space. The stack is threadsafe (each thread will have its own stack) but theheap is not threadsafe unless guarded with synchronisation through your code.A method in stack is re-entrant allowing multiple concurrent invocations that do not interfere with each other. Afunction is recursive if it calls itself. Given enough stack space, recursive method calls are perfectly valid in Javathough it is tough to debug. Recursive functions are useful in removing iterations from many sorts of algorithms. Allrecursive functions are re-entrant but not all re-entrant functions are recursive. Idempotent methods are methods,which are written in such a way that repeated calls to the same method with the same arguments yield sameresults. For example clustered EJBs, which are written with idempotent methods, can automatically recover from aserver failure as long as it can reach another server.H3#@11. What do you know about the Java garbage collector? When does the garbage collection occur? Explain different types of references in Java?Each time an object is created in Java, it goes into the area of memory known as heap. The Java heap is calledthe garbage collectable heap. The garbage collection cannot be forced. The garbage collector runs in lowmemory situations. When it runs, it releases the memory allocated by an unreachable object. The garbagecollector runs on a low priority daemon (background) thread. You can nicely ask the garbage collector to collectgarbage by calling System.gc() but you can’t force it.H4#@What is an unreachable object? An object’s life has no meaning unless something has reference to it. If you can’t reach it then you can’t ask it to do anything. Then the object becomes unreachable and the garbage collectorwill figure it out. Java automatically collects all the unreachable objects periodically and releases the memoryconsumed by those unreachable objects to be used by the future reachable objects.H3#@12. What is the difference between yield and sleeping?When a task invokes yield(), it changes from running state to runnable state. yield() method pauses the currently executing thread temporarily for giving a chance to the remaining waiting threads of the same priority to execute. If there is no waiting thread or all the waiting threads have a lower priority then the same thread will continue its execution. When a task invokes sleep(), itchanges from running state to waiting/sleeping state.H3#@13. How does thread synchronization occurs inside a monitor? What levels of synchronization can you apply? What is the difference between synchronized method and synchronized block?In Java programming, each object has a lock. A thread can acquire the lock for an object by using thesynchronized keyword. The synchronized keyword can be applied in method level (coarse grained lock – canaffect performance adversely) or block level of code (fine grained lock). Often using a lock on a method level istoo coarse. Why lock up a piece of code that does not access any shared resources by locking up an entiremethod. Since each object has a lock, dummy objects can be created to implement block level synchronization.The block level is more efficient because it does not lock the whole method.b#@The JVM uses locks in conjunction with monitors. A monitor is basically a guardian who watches over a sequenceof synchronized code and making sure only one thread at a time executes a synchronized piece of code. Eachmonitor is associated with an object reference. When a thread arrives at the first instruction in a block of code itmust obtain a lock on the referenced object. The thread is not allowed to execute the code until it obtains the lock.H3#@14.What is a daemon thread?Daemon threads are sometimes called "service" threads. These are threads that normally run at a low priority andprovide a basic service to a program or programs when activity on a machine is reduced. An example of a daemonthread that is continuously running is the garbage collector thread. This thread is provided by the JVM. H3#@15. Difference between java IO vs NIOH4#@Stream Oriented vs. Buffer OrientedThe first big difference between Java NIO and IO is that IO is stream oriented, where NIO is buffer oriented. So, what does that mean?Java IO being stream oriented means that you read one or more bytes at a time, from a stream. What you do with the read bytes is up to you. They are not cached anywhere. Furthermore, you cannot move forth and back in the data in a stream. If you need to move forth and back in the data read from a stream, you will need to cache it in a buffer first.b#@Java NIO's buffer oriented approach is slightly different. Data is read into a buffer from which it is later processed. You can move forth andback in the buffer as you need to. This gives you a bit more flexibility during processing. However, you also need to check if the buffer contains all the data you need in order to fully process it. And, you need to make sure that when reading more data into the buffer, you do not overwrite data in the buffer you have not yet processed.H4#@Blocking vs. Non-blocking IOJava IO's various streams are blocking. That means, that when a thread invokes a read() or write(), that thread is blocked until there is some data to read, or the data is fully written. The thread can do nothing else in the meantime.Java NIO's non-blocking mode enables a thread to request reading data from a channel, and only get what is currently available, or nothing at all, if no data is currently available. Rather than remain blocked until data becomes available for reading, the thread can go on with something else.b#@The same is true for non-blocking writing. A thread can request that some data be written to a channel, but not wait for it to be fully written. The thread can then go on and do something else in the mean time.What threads spend their idle time on when not blocked in IO calls, is usually performing IO on other channels in the meantime. That is, a single thread can now manage multiple channels of input and output.H3#@16. What is the order of method invocation in an applet?public void init() : Initialization method called only once by the browser.• public void start() : Method called after init() and contains code to start processing. If the user leaves thepage and returns without killing the current browser session, the start () method is called without beingpreceded by init ().• public void stop() : Stops all processing started by start (). Done if user moves off page.• public void destroy() : Called if current browser session is being terminated. Frees all resources used by theapplet. H3#@17. How would you improve performance of a Java application?bo#@Pool valuable system resourceslike threads, database connections, socket connections etc. Emphasise onreuse of threads from a pool of threads. Creating new threads and discarding them after use can adverselyaffect performance. Also consider using multi-threading in your single-threaded applications where possible toenhance performance. Optimze the pool sizes based on system and application specifications andrequirements.b#@bo#@Optimize your I/O operations:use bufferingb#@bo#@Minimize network overheadsretrieving several related items simultaneously in one remote invocation ifpossible.b#@b#@Establish whether you have a potential memory problem and manage your objects efficientlyH3#@18. Please suggest some good book for Java concurrency?a#@http://www.johnchukwuma.com/training/java_concurrency_in_practice.pdf#JavaConcurrencyH3#@19.	What is thread local?ThreadLocal is an alternative to the usage of global variable passed from methods to methods as argument (brute force technique) or static variable (visible within the current ClassLoader).b#@However, unlike global or static variable, the ThreadLocal scope is limited to the execution of the current thread, thus its name. A ThreadLocal attached to Thread1 cannot be access by Thread2 and vice versa. This thread isolation makes ThreadLocal thread-safe by nature,unlike static variables which need synchronization (thus performance overhead).b#@A ThreadLocal object is created, then attached to the current thread. All portion of your program executed by the current thread can access the ThreadLocal target Object, provided that the code can access the ThreadLocal reference, and that’s the trick! There is no point creating a ThreadLocal if it cannot be accessed everywhere in your code.b#@Most of the time, the ThreadLocal object itself is created as a static final variable. Static to make it accessible from everywhere and final to avoid being modified. There is no need to synchronize the access to the ThreadLocal object itself since only the target Object is useful and this object is different from one thread to another (so thread-safe by nature).CODE_START#START_SNIPPETpackage test; public class ThreadLocalManager{    public static final ThreadLocal myThreadLocal = new ThreadLocal();} public class TestThreadLocal implements Runnable{     private String value;    private long delayTime;    private long sleepTime;     public TestThreadLocal(String value, long delayTime, long sleepTime) {        this.value = value;        this.delayTime = delayTime;        this.sleepTime = sleepTime;    }     @Override    public void run()    {         try        {            Thread.sleep(this.delayTime);            System.out.println("[" + this + "] is setting myThreadLocal [" + ThreadLocalManager.myThreadLocal + "] the value : " + this.value);            ThreadLocalManager.myThreadLocal.set(this.value);            Thread.sleep(this.sleepTime);            System.out.println("[" + this + "] is accessing myThreadLocal [" + ThreadLocalManager.myThreadLocal + "] value : "                    + ThreadLocalManager.myThreadLocal.get());        }        catch (InterruptedException e)        {            e.printStackTrace();        }     }     public static void main(String[] args)    {        TestThreadLocal test1 = new TestThreadLocal("V1", 0, 200);        System.out.println("Creating test1 : " + test1);        TestThreadLocal test2 = new TestThreadLocal("V2", 100, 500);        System.out.println("Creating test2 : " + test2);        Thread t1 = new Thread(test1);        Thread t2 = new Thread(test2);         t1.start();        t2.start();    } }CODE_END#