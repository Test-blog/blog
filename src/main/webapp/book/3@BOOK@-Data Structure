H3#@1.	How to check tree if binary tree is balanced tree:
CODE_START#
START_SNIPPET
getHeight(Node node){
	if(node==null){return 0;}
	return Math.max(getHeight(node.left),getHeight(node.right))+1;
}

boolean isBalanced(Node node){
	int height = getHeight(node.left) - getHeight(node.right);
	if(height>1){return false;}
	else{
	isBalanced(node.left) && isBalanced(node.right);
}
CODE_END#

H3#@2.	Reverse linked list.

CODE_START#
START_SNIPPET
/* Function to reverse a Doubly Linked List */
void reverse(struct node **head_ref)
{
     struct node *temp = NULL;  
     struct node *current = *head_ref;
      
     /* swap next and prev for all nodes of 
       doubly linked list */
     while (current !=  NULL)
     {
       temp = current->prev;
       current->prev = current->next;
       current->next = temp;              
       current = current->prev;
     }          
}     
CODE_END#
H4#@Singly linked list
CODE_START#
START_SNIPPET
/* Function to reverse a Singly Linked List */
void reverse(struct node **head_ref)
{
     struct node *temp = NULL;  
     struct node *current = *head_ref;
	 struct node *result = NULL;  
      
     /* swap next and prev for all nodes of 
       singly linked list */
     while (current !=  NULL)
     {
       temp = current->next;
       current->next = result;
       result = current;              
       current = temp;
     }          
}     
CODE_END#


H3#@3. BFS Traversal
H4#@BFS using Queue
CODE_START#
START_SNIPPET
printLevelorder(tree)
1) Create an empty queue q
2) temp_node = root /*start from root*/
3) Loop while temp_node is not NULL
    a) print temp_node->data.
    b) Enqueue temp_node's children (first left then right children) to q
    c) Dequeue a node from q and assign it's value to temp_node
CODE_END#


H4#@BFS without using Queue: Recursive
CODE_START#
START_SNIPPET
/*Function to print level order traversal of tree*/
printLevelorder(tree)
for d = 1 to height(tree)
   printGivenLevel(tree, d);

/*Function to print all nodes at a given level*/
printGivenLevel(tree, level)
if tree is NULL then return;
if level is 1, then
    print(tree->data);
else if level greater than 1, then
    printGivenLevel(tree->left, level-1);
    printGivenLevel(tree->right, level-1);
CODE_END#


H3#@4. Check if binary tree is BST.
1. In order Traversal
2. Make sure :  INTEGER_MIN <  left node child <  current.node  (isthisBSTUtil(root->left, min, root->data))
3. And make sureL current.node <  right  node child <  INTEGER.MAX (isthis BSTUtil(root->right,root->data, max)

CODE_START#
START_SNIPPET
bool isthisBST(nodeptr root)
{
	return isthisBSTUtil(root,INT_MIN, INT_MAX);
}

int isthisBSTUtil(nodeptr root, int min, int max)
{
	if(root == NULL) return true; //empty tree is a bst
	if(root-data <  min || root->data >max) return false;
	return (isthisBSTUtil(root->left, min, root->data) || isthis BSTUtil(root->right,root->data, max);
}
CODE_END#


H3#@Perform binary search
CODE_START#
START_SNIPPET
public static int binarySearch( Comparable [ ] a, Comparable x )
    {
        int low = 0;
        int high = a.length - 1;
        int mid;

        while( low < = high )
        {
            mid = ( low + high ) / 2;

            if( a[ mid ].compareTo( x ) <  0 )
                low = mid + 1;
            else if( a[ mid ].compareTo( x ) > 0 )
                high = mid - 1;
            else
                return mid;
        }

        return NOT_FOUND;     // NOT_FOUND = -1
	}
CODE_END#


H3#@5. Find or determine non existence of a number in a sorted list of N numbers where the numbers range over M, M >> N and N large enough to span multiple disks. Algorithm to beat O(log n) bonus points for constant time algorithm.
This problem can be solved using bitmaps.bitmap will be an array (say b_array) where we have one bit per M possible number. If we use a character array to store bitmaps, b_array size will be M/8, since 1 char can store 8 bits. Bitmap array will be initialized to zero first. Now for each of the N numbers its corresponding bit should be turned on(1). Corresponding bit for 'n' can be found as follows:
CODE_START#
START_SNIPPET
base = n/8; (base is the char whose certain bit needs to be set)

offset = 1 < <  (n mod 8); (offset is the bit to be set)

b_array[base] |= offset; (I set the particular bit)

Once this is done of all N numbers, given a number m,
we can first find corresponding  bit offset and check whether it is one.

base = m/8; (base is the char whose certain bit needs to be set)

offset = 1 < <  (m mod 8); (offset is the bit to be set)

if (b_array[base] & offset)
    // found the number
else
    //number could not be found

CODE_END#




H3#@6. Find height of Binary tree without recursion 
CODE_START#
START_SNIPPET
int maxDepthIterative(BinaryTree *root) {
  if (!root) return 0;
  stack< BinaryTree*> s;
  s.push(root);
  int maxDepth = 0;
  BinaryTree *prev = NULL;

  while (!s.empty()) {
    BinaryTree *curr = s.top();
    if (!prev || prev->left == curr || prev->right == curr) {
      if (curr->left)
        s.push(curr->left);
      else if (curr->right)
        s.push(curr->right);
    } else if (curr->left == prev) {
      if (curr->right)
        s.push(curr->right);
    } else {
      s.pop();
    }
    prev = curr;
    if (s.size() > maxDepth)
      maxDepth = s.size();
  }
  return maxDepth;
}
CODE_END#



H3#@7. Convert Binary Search to Doubly linked list
CODE_START#
START_SNIPPET

			1
		2		3
	4	   5

[1] Do in order traversal
traversal(node.left)
Logic
traversal(node.right)
[2] Logic
(a) need to link left of list as Previous node of our in-order traversal, i.e.: for 2 left = previous 4
(b) and for 4 left = null so, 4 should be head.
4-2-5-1-3
 
void convertBSTToDLL(treenode* curNode, treenode*& prevNode, treenode*& listHead)
{
    if (curNode)
    {
		//[1] Traversal left
        convertBSTToDLL(curNode->left, prevNode, listHead);
		
		//[2] Logic
        if (prevNode)
        {
            curNode->left = prevNode;
            prevNode->right = curNode;
        }
        else
        {
            listHead = curNode;
        }
        prevNode = curNode;
		
		//[3] Traversal right
        convertBSTToDLL(curNode->right, prevNode, listHead);
    }
    return;
}
CODE_END#

H3#@8.	Convert  decimal to binary
CODE_START#
START_SNIPPET
import java.util.*;

public class number
{
	public static void main (String [] args)
	{
		Scanner input = new Scanner (System.in);
		System.out.println ("Input decimal number");
		int decimal = input.nextInt ();
		input.close ();
		
		int base = 2;
		int result = 0;
		int multiplier = 1;
		
		while (decimal>0)
		{
			int residue = decimal%base;
			decimal = decimal/base;
			result = result +residue*multiplier;
			multiplier = multiplier * 10;
		}
		System.out.println ("binary....."+result);
	}
}
CODE_END#



H3#@9.	COnvert decimal to Hex
CODE_START#
START_SNIPPET
function toHex(d) {
  var r = d % 16;
  var result;
  if (d-r == 0) 
    result = toChar(r);
  else 
    result = toHex( (d-r)/16 ) + toChar(r);
  return result;
}
 
function toChar(n) {
  const alpha = "0123456789ABCDEF";
  return alpha.charAt(n);
}
CODE_END#



H3#@10.	Write DFS using stack.
CODE_START#
START_SNIPPET
public void dfs()
{
	//DFS uses Stack data structure
	Stack s=new Stack();
	s.push(this.rootNode);
	rootNode.visited=true;
	printNode(rootNode);
	while(!s.isEmpty())
	{
		Node n=(Node)s.peek();
		Node child=getUnvisitedChildNode(n);
		if(child!=null)
		{
			child.visited=true;
			printNode(child);
			s.push(child);
		}
		else
		{
			s.pop();
		}
	}
	//Clear visited property of nodes
	clearNodes();
}
CODE_END#


H3#@11.	Write BFS using queue
CODE_START#
START_SNIPPET
public void bfs()
{
	//BFS uses Queue data structure
	Queue q=new LinkedList();
	q.add(this.rootNode);
	printNode(this.rootNode);
	rootNode.visited=true;
	while(!q.isEmpty())
	{
		Node n=(Node)q.remove();
		Node child=null;
		while((child=getUnvisitedChildNode(n))!=null)
		{
			child.visited=true;
			printNode(child);
			q.add(child);
		}
	}
	//Clear visited property of nodes
	clearNodes();
}
CODE_END#



H3#@12. Given a sorted array of integers, how can you find the location of a particular integer x?
Use binary search. Compare the number in the middle of the array
with x. If it is equal, we are done. If the number is greater, we know to look in the
second half of the array. If it is smaller, we know to look in the first half. We can
repeat the search on the appropriate half of the array by comparing the middle
element of that array with x, once again narrowing our search by a factor of 2. We
repeat this process until we find x. This algorithm takes O(log n) time.


H3#@13.	What is Mutexes and semaphores:
bo#@Mutex:
A mutex is like a lock. Mutexes are used in parallel programming to ensure that only
one thread can access a shared resource at a time. For example, say one thread is
modifying an array. When it has gotten halfway through the array, the processor
switches to another thread. If we were not using mutexes, the thread might try to
modify the array as well, which is probably not what we want.
b#@
To prevent this, we could use a mutex. Conceptually, a mutex is an integer that
starts at 1. Whenever a thread needs to alter the array, it "locks" the mutex. This
causes the thread to wait until the number is positive and then decreases it by one.
When the thread is done modifying the array, it "unlocks" the mutex, causing the
number to increase by 1. If we are sure to lock the mutex before modifying the
array and to unlock it when we are done, then we know that no two threads will
modify the array at the same time.
b#@
bo#@Semaphores
Semaphores are more general than mutexes. They differ only in that a semaphore's
integer may start at a number greater than 1. The number at which a semaphore
starts is the number of threads that may access the resource at once. Semaphores
support "wait" and "signal" operations, which are analogous to the "lock" and
"unlock" operations of mutexes.



H3#@14.	Write a function to convert a string into an integer.
Go through the string from beginning to end. If the first character is a
negative sign, remember this fact. Keep a running total, which starts at 0. Each time
you reach a new digit, multiply the total by 10 and add the new digit. When you
reach the end, return the current total, or, if there was a negative sign, the inverse of
the number.




H3#@15.	Merge Sort
Merge sort is a recursive way to sort an array. First, you divide the array in half and
recursively sort each half of the array. Then, you combine the two halves into a
sorted array. So a merge sort function would look something like this:
img#@http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif
CODE_START#
START_SNIPPET
void mergeSort(int numbers[], int temp[], int array_size)
{
        m_sort(numbers, temp, 0, array_size - 1);
}
void m_sort(int numbers[], int temp[], int left, int right)
{
       int mid;
        if (right > left)
        {
            mid = (right + left) / 2;
            m_sort(numbers, temp, left, mid);
            m_sort(numbers, temp, mid+1, right);
            merge(numbers, temp, left, mid+1, right);
        }
}
void merge(int numbers[], int temp[], int left, int mid, int right)
        {
           int i, left_end, num_elements, tmp_pos;
           left_end = mid - 1;
            tmp_pos = left;
            num_elements = right - left + 1;
while ((left < = left_end) && (mid < = right))
        {
                if (numbers[left] < = numbers[mid])
                {
                        temp[tmp_pos] = numbers[left];
                        tmp_pos = tmp_pos + 1;
                        left = left +1;
                }
                else
                {
                        temp[tmp_pos] = numbers[mid];
                        tmp_pos = tmp_pos + 1;
                        mid = mid + 1;
                }
        }
        while (left < = left_end)
                {
                        temp[tmp_pos] = numbers[left];
                        left = left + 1;
                        tmp_pos = tmp_pos + 1;
                }
                while (mid < = right)
                {
                        temp[tmp_pos] = numbers[mid];
                        mid = mid + 1;
                        tmp_pos = tmp_pos + 1;
                }
                for (i = 0; i < = num_elements; i++)
                {
                        numbers[right] = temp[right];
                        right = right - 1;
                }
        }
CODE_END#

H3#@15.a	Merging two sorted linked lists
CODE_START
START_SNIPPET
public void merge(int[] A, int[] B, int[] C) {
      int i, j, k, m, n;
      i = 0;
      j = 0;
      k = 0;
      m = A.length;
      n = B.length;
      while (i <  m && j <  n) {
            if (A[i] < = B[j]) {
                  C[k] = A[i];
                  i++;
            } else {
                  C[k] = B[j];
                  j++;
            }
            k++;
      }
      if (i <  m) {
            for (int p = i; p <  m; p++) {
                  C[k] = A[p];
                  k++;
            }
      } else {
            for (int p = j; p <  n; p++) {
                  C[k] = B[p];
                  k++;
            }
      }
}
CODE_END#

H3#@16.	Write a program to determine whether an input string x is a substring of another input string y.
CODE_START#
START_SNIPPET
bool hasSubstring(const char *str, const char *find) {
	if (str[0] == '\0' && find[0] == '\0')
		return true;
	for(int i = 0; str[i] != '\0'; i++) {
		bool foundNonMatch = false;
		for(int j = 0; find[j] != '\0'; j++) {
			if (str[i + j] != find[j]) {
			foundNonMatch = true;
			break;
			}
		}
	if (!foundNonMatch)
	return true;
	}
	return false;
}
CODE_END#


H3#@17.	Write program : non-recursive in-order traversal
CODE_START#
START_SNIPPET
void inorder( node *root)
{
	node *p;
	p=root;
	top=0;
	do
	{
		while(p!=NULL)
		{
			stk[top]=p->data;
			top++;
			p=p->left;
		}
		if(top>0)
		{
			p=pop(root);
			cout < <  p->data;
			p=p->right;
		}
	}while(top!=0 || p!=NULL);
}
CODE_END#








H3#@18.	Find 5th largest element from BST.
CODE_START#
START_SNIPPET
int num=0;
void max(tree*t)
{
        if(t==NULL)
                return;
        max(t->right);
        num++;
        if(num==5)
                printf("%d\n",t->no);
        max(t->left);
}
CODE_END#



H3#@19.	FInd lowest common ancestor for two nodes in binary tree.
CODE_START#
START_SNIPPET
treeNodePtr findLCA(treeNodePtr root, treeNodePtr p, treeNodePtr q) {

        // no root no LCA.
        if(!root) {
                return NULL;
        }

        // if either p or q is the root then root is LCA.
        if(root==p || root==q) {
                return root;
        } else {
                // get LCA of p and q in left subtree.
                treeNodePtr l=findLCA(root->left , p , q);

                // get LCA of p and q in right subtree.
                treeNodePtr r=findLCA(root->right , p, q);

                // if one of p or q is in leftsubtree and other is in right
                // then root it the LCA.
                if(l && r) {
                        return root;
                }
                // else if l is not null, l is LCA.
                else if(l) {
                        return l;
                } else {
                        return r;
                }
        }
}
CODE_END#


H3#@20.	Print possible closed parenthesis pairs program.
i.e.: Pair = 3
Combinations should be:
((())))
(()())
(())()
()(())
()()()
CODE_START#
START_SNIPPET
public class App 
{
	 static int total = 3;

	    static private void Brackets(String output, int open, int close, int pairs) {
	        if ((open == pairs) && (close == pairs) && output.length() == total * 2) {
	            System.out.println(output);
	        } else {
	            if (open <  pairs)
	                Brackets(output + "(", open + 1, close, pairs);
	            if (close <  open)
	                Brackets(output + ")", open, close + 1, pairs);
	        }

	    }

	    public static void main(String[] args) {
	        Brackets("", 0, 0, 3);
	    }
}
CODE_END#


H3#@21. Permutation for a given characters.
CODE_START#
START_SNIPPET
public class Permute {

	void permute( String str ){
	    int          length = str.length();
	    boolean[]    used = new boolean[ length ];
	    StringBuffer out = new StringBuffer();
	    char[]       in = str.toCharArray();

	    doPermute( in, out, used, length, 0 );
	}

	void doPermute( char[] in, StringBuffer out,
	                boolean[] used, int length, int level ){
	    if( level == length ){
	        System.out.println( out.toString() );
	        return;
	    }

	    for( int i = 0; i <  length; ++i ){
	        if( used[i] ) continue;

	        out.append( in[i] );
	        used[i] = true;
	        doPermute( in, out, used, length, level + 1 );
	        used[i] = false;
	        out.setLength( out.length() - 1 );
	    }
	}

	
}
CODE_END#

H3#@22. Design a class library for writing card games.
CODE_START#
START_SNIPPET
public class Card{
    private short rank, suit;

    private static String[] suits = { "hearts", "spades", "diamonds", "clubs" };
    private static String[] ranks  = { "Ace", "2", "3", "4", "5", "6", "7", 
                   "8", "9", "10", "Jack", "Queen", "King" };

    public static String rankAsString( int __rank ) {
        return ranks[__rank];
    }
public short getRank() {
         return rank;
    }

    public short getSuit() {
        return suit;
    }
}

(win)		isPair,isRed,handTotal
game- player - pile---
|			|
Deck-Icard------  Card
(shuffle,		(getSuit,getRank)
isFlush,
handTotal)

CODE_END#


H3#@23. Define types of cookies.
bo#@Session cookie:
A session cookie only lasts for the duration of users using the website. A session cookie will expire if a user closes his/her browser, or if a user hasn't visited the server for certain period of time (called session idle timeout), and the server would expire/invalidate the user session.
b#@
bo#@Persistent cookie:
A persistent cookie will outlast user sessions. If a persistent cookie has Max-Age set to 1 year, then, within the year, the initial value set in that cookie would be sent back to server every time the user is visiting the server. This could be used to record a vital piece of information such as how the user initially came to this website. For this reason, persistent cookie is also called tracking cookie
b#@
bo#@Secure cookie:
A secure cookie is only used when a browser is visiting a server via HTTPS, that will make sure that cookie is always encrypted when transmitting from client to server, and therefore less likely to be exposed to cookie theft via eavesdropping.
b#@
bo#@HttpOnly cookie:
HttpOnly cookie is still in IETF draft[8], though most of the modern browsers support it. On a supported browser, a HttpOnly cookie will only be used when transmitting HTTP (or HTTPS) requests, but the cookie value is not available to client side script, hence mitigate the threat of cookie theft via Cross-site scripting.
b#@
bo#@Third-party cookie:
First-party cookies are cookies set with the same domain or its subdomain in your browser's address bar. Third-party cookies are cookies being set with different domains than the one shown on address bar.
For example: Suppose a user visits www.example1.com, it sets a cookie with domain ad.foxytracking.com. When the user later visits www.example2.com, another cookie is placed with domain ad.foxytracking.com, eventually these cookies will be sent to the advertiser when loading their ads or visiting their website, the advertiser can then build up users' browsing history across all the websites this advertiser has footprints on.
b#@
bo#@Super cookie:
A Super cookie is a cookie with a Public Suffix [9] domain, like .com, .co.uk or k12.ca.us.
Most browsers, by default, allow first-party cookies, i.e., a cookie with domain to be the same or sub-domain of the requesting host. For example, a user visiting www.example.com can have a cookie set with domain www.example.com or .example.com, but not .com. A super cookie with domain .com would be blocked by browsers; otherwise, attacker.com could set a super cookie with domain .com and potentially disrupt or impersonate legitimate user requests to example.com. Unfortunately, the Public Suffix List keeps changing, and older versions of browsers will not have the most up-to-date list, and will therefore be vulnerable to certain super cookies.
b#@
bo#@Zombie cookie:
A zombie cookie is any cookie that is automatically recreated after a user has deleted it. This is accomplished by a script storing the content of the cookie in some other location, such as the local storage available to Flash content, and then recreating it from the backup when the cookie's absence is detected.

H3#@ Given two strings, check if one string is a permutation of the other.
b#@ Solution 1: Sort the string and verify
b#@ Solution 2:  Check if the two strings have identical characters count.




H3#@24.	ROTATE A MATRIX BY 90 DEGREES

b#@[1,  2, 3, 4]                   [9, 6, 9, 1]
b#@[9, 8, 5, 6]         –>       	[2, 5, 8, 2]
b#@[6, 5, 3, 7]                    [6, 3, 5, 3]
b#@[9, 2, 6, 8]                    [8, 7, 6, 4]
b#@
In our example we have two layers:
b#@
b#@OUTER LAYER         			 INNER LAYER
b#@1 2 3 4
b#@9      6                               8 5
b#@6      7                               5 3
b#@9 2 6 8

At each layer we are gonna loop through the elements and swap them as follows:
b#@1.- Save the ith element in the top array in a temporary variable (in our example the top array is [1 2 3 4] ).
b#@2.- Move the ith element from left to top.
b#@3.- Move the ith element from bottom to left.
b#@4.- Move the ith element from right to bottom.
b#@5.- Save the value of our temporary variable in the ith position in the right array.
b#@Tip: Draw 4*4 matrix and run above steps on paper. It will tell you the solution.

CODE_START#
START_SNIPPET
public static void rotate(int[][] matrix, int n) {
 for (int layer = 0; layer <  n / 2; ++layer) {
	int first = layer;
	int last = n - 1 - layer;
	for(int i = first; i <  last; ++i) {
		 int offset = i - first;
		 int top = matrix[first][i]; // save top
		 // left -> top
		 matrix[first][i] = matrix[last-offset][first]; 
		 
		 // bottom -> left
		 matrix[last-offset][first] = matrix[last][last - offset]; 
		 
		 // right -> bottom
		 matrix[last][last - offset] = matrix[i][last]; 
		 
		 // top -> right
		 matrix[i][last] = top; // right < - saved top
		 }
 }
 }
CODE_END#






H3#@25.	Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column is set to 0.
Track which column and row is having 0. and make all rows and columns 0 for that matrix.
CODE_START#
START_SNIPPET
 public static void setZeros(int[][] matrix) {
	 int[] row = new int[matrix.length]; 
	 int[] column = new int[matrix[0].length];
 // Store the row and column index with value 0
	for (int i = 0; i <  matrix.length; i++) {
		for (int j = 0; j <  matrix[0].length;j++) {
		 if (matrix[i][j] == 0) {
		 row[i] = 1; 
		 column[j] = 1;
		 }
	}
 }
 
 // Set arr[i][j] to 0 if either row i or column j has a 0
	 for (int i = 0; i <  matrix.length; i++) {
		 for (int j = 0; j <  matrix[0].length; j++) {
			 if ((row[i] == 1 || column[j] == 1)) {
			 matrix[i][j] = 0;
			 }
		}
	 }
 }
CODE_END#



H3#@26.	Assume you have a method isSubstring which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring (i.e., "waterbottle" is a rotation of "erbottlewat").
CODE_START#
START_SNIPPET
 public static boolean isRotation(String s1, String s2) {
	 int len = s1.length();
	 /* check that s1 and s2 are equal length and not empty */
	 if (len == s2.length() && len > 0) { 
		 /* concatenate s1 and s1 within new buffer */
		 String s1s1 = s1 + s1;
		 return isSubstring(s1s1, s2);
	 }
	 return false;
 }
CODE_END#




H3#@27.	Given a directed graph, design an algorithm to find out whether there is a route between two nodes. 
This problem can be solved by just simple graph traversal, such as depth first search or breadth first search. Start one of the two nodes and traverse with BFS or DFS.
CODE_START#
START_SNIPPET
	public static boolean search(Graph g, Node start, Node end) { 

	LinkedList< Node> q = new LinkedList< Node>(); // operates as Stack 
	for (Node u : g.getNodes()) { 

	u.state = State.Unvisited; 

	} 

	start.state = State.Visiting; 

	q.add(start); 

	Node u; 

	while(!q.isEmpty()) { 

	u = q.removeFirst(); // i.e., pop() 
	if (u != null) { 
	for (Node v : u.getAdjacent()) { 
		if (v.state == State.Unvisited) {
		if (v == end) {
		return true;
		} else {
		v.state = State.Visiting;
		q.add(v);
		}
		}
	} 
	u.state = State.Visited; 
	} 
} 

	return false; 

CODE_END#





H3#@28.	Given a sorted (increasing order) array, write an algorithm to create a binary tree with minimal height.
We will try to create a binary tree such that for each node, the number of nodes in the left subtree and the right subtree are equal, if possible.
b#@
bo#@Algorithm:

1.	Insert into the tree the middle element of the array. 
2.	Insert (into the left subtree) the left subarray elements 
3.	Insert (into the right subtree) the right subarray elements 
4.	Recurse 

CODE_START#
START_SNIPPET
public static TreeNode addToTree(int arr[], int start, int end){ 
	if (end <  start) { 
	return null; 
	} 
	int mid = (start + end) / 2; 
	TreeNode n = new TreeNode(arr[mid]); 
	n.left = addToTree(arr, start, mid - 1); 
	n.right = addToTree(arr, mid + 1, end); 
	return n; 
} 

public static TreeNode createMinimalBST(int array[]) { 
	return addToTree(array, 0, array.length - 1); 
} 

CODE_END#




H3#@29.	 Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each depth (eg, if you have a tree with depth D, you'll have D linked lists).
CODE_START#
START_SNIPPET
ArrayList< LinkedList< TreeNode>> findLevelLinkList(TreeNode root) { 
	int level = 0; 
	ArrayList< LinkedList< TreeNode>> result = new ArrayList< LinkedList< TreeNode>>(); 
	LinkedList< TreeNode> list = new LinkedList< TreeNode>(); 

	list.add(root); 
	result.add(level, list); 

	while (true) { 
		list = new LinkedList< TreeNode>(); 
		for (int i = 0; i <  result.get(level).size(); i++) { 
			TreeNode n = (TreeNode) result.get(level).get(i); 
			if (n != null) { 
				if(n.left !=	null)	list.add(n.left);
				if(n.right!=	null)	list.add(n.right);
			} 
		} 	
		if (list.size() > 0) { 
			result.add(level + 1, list); 
		} else { 
			break; 
		} 
		level++; 
	} 
	return result; 
} 

CODE_END#
b#@
We can also implement is with recurssive call.
CODE_START#
START_SNIPPET

List< LinkedList< TreeNode>> createBreathLinkedList(TreeNode root){
	List< LinkedList< TreeNode>> list = new ArrayList< LL< TreeNode>>();
	createBreathListRecurssive(root,list,0/*root at 0 level*/);
}

void createBreathListRecurssive(TreeNode root, List< LinkedList< TreeNode>> lists,int level){
	
	if(root==null){return null;}
	
	LinkedList< TreeNode> list = null;
	if(lists.size()==level) { /*we add breath linked list into list.so, each sub linked list at each level*/
		list = new LinkedList< TreeNode>();
		lists.add(list);
	}else{
		list = lists.get(level);
	}
	list.add(root);
	createBreathListRecurssive(root.left,lists,level+1);
	createBreathListRecurssive(root.right,lists,level+1);
}
CODE_END#



H3#@30.	Check if binary tree is binary search tree.
CODE_START#
START_SNIPPET
boolean checkBST(TreeNode n){
	return checkBST(n,INT_MIN,INT_MAX);
}

boolean checkBST(TreeeNode node,int min,int max){
	
	if(node==null){return true;}

	int value = node.getValue();
	
	if(value< =min || value>max){return false;}
	
	if(!checkBST(node.left,min,value) || !checkBST(node.right,value,max)){return false;}
	return true;
	
}
CODE_END#


H3#@31.	Write an algorithm to find the NEXT node (e.g., in-order successor) of a given node in a binary search tree where each node has a link to its parent. 
We will do in order traversal.
b#@
1.	If X has a right child, then the successor must be on the right side of X (because of the order in which we visit nodes). Specifically, the left-most child must be the first node visited in that subtree. 
2.	Else, we go to X s parent (call it P). 
2.a. If X was a left child (P.left = X), then P is the successor of X
2.b. If X was a right child (P.right = X), then we have fully visited P, so we call successor(P).
b#@
CODE_START#
START_SNIPPET
public static TreeNode inorderSucc(TreeNode e) { 
	if (e != null) { 
	TreeNode p; 
	// Found right children -> return 1st inorder node on right 
	if (e.parent == null || e.right != null) { 
		p = leftMostChild(e.right); 
	} else { 
	// Go up until we're on left instead of right (case 2b) 
	while ((p = e.parent) != null) { 
		if (p.left == e) { /* if node == node.parent.left -> then according to in-order parent is next*/
		break;
		}
		e = p; /* else assign parent to e and traverse further up*/
	} 
	} 
	return p; 
} 
return null; 
} 
public static TreeNode leftMostChild(TreeNode e) { 
	if (e == null) return null; 
	while (e.left != null) e = e.left; 
	return e; 
} 
CODE_END#



H3#@32.	Write a function to determine the number of bits required to convert integer A to integer B.
1.	XOR A and B. --> It will give you how many bits are different
2. Right shift by 1 and increment the count to calculate difference 
CODE_START#
START_SNIPPET
public static int bitSwapRequired(int a, int b) { 
int count = 0; 
for (int c = a ^ b; c != 0; c = c >> 1) { 
	count += c & 1; 
} 
return count; 
} 

CODE_END#



H3#@33.	Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, etc). 
Mask all odd bits with 10101010 in binary (which is 0xAA), then shift them left to put them in the even bits. Then, perform a similar operation for even bits. This takes a total 5 instructions.
CODE_START#
START_SNIPPET
public static int swapOddEvenBits(int x) { 
	return ( ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) < <  1) ); 
} 
CODE_END#



H3#@34.	Given an input file with four billion integers, provide an algorithm to generate an integer which is not contained in the file. Assume you have 1 GB of memory.
It's possible to find a missing integer with just two passes of the data set. We can divide up the integers into blocks of some size (we'll discuss how to decide on a size later). Let's just as-sume that we divide up the integers into blocks of 1000. So, block 0 represents the numbers 0 through 999, block 1 represents blocks 1000 - 1999, etc. Since the range of ints is finite, we know that the number of blocks needed is finite.




H3#@35.	You have an array with all the numbers from 1 to N, where N is at most 32,000. The array may have duplicate entries and you do not know what N is. With only 4KB of memory available, how would you print all duplicate elements in the array? 
We have 4KB of memory which means we can address up to 8 * 4 * (2^10) bits. Note that 32* (2^10) bits is greater than 32000. We can create a bit vector with 32000 bits, where each bit represents one integer.
CODE_START#
START_SNIPPET

boolean get(int pos) { 
	int wordNumber = (pos >> 5); // divide by 32 
	int bitNumber = (pos & 0x1F); // mod 32 
	return (bitset[wordNumber] & (1 < <  bitNumber)) != 0; 
} 

void set(int pos) { 
	int wordNumber = (pos >> 5); // divide by 32 
	int bitNumber = (pos & 0x1F); // mod 32 
	bitset[wordNumber] |= 1 < <  bitNumber; 
} 
CODE_END#



H3#@36.	If you were designing a web crawler, how would you avoid getting into infinite loops? 
Page: www.google.com and www.google.com?query could be same. So, url should not be unique attribute for page.
CODE_START#
START_SNIPPET
1.	Open page and create signature of page based on some specific content
2.	Query database if something is similar to it then put that record back to DB with low priority
3. 	If not then crawl page and put children to db back.
4.	Perform DFS to traverse through DB records.
CODE_END#



H3#@37.	You are given two sorted arrays, A and B, and A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order. 
Start from end of A and B. Shift the largest element at the end of buffer of A.
CODE_START#
START_SNIPPET
public static void merge(int[] a, int[] b, int n, int m) { 
	int k = m + n - 1; // Index of last location of array b 
	int i = n - 1; // Index of last element in array b 
	int j = m - 1; // Index of last element in array a 

	// Start comparing from the last element and merge a and b 
while (i >= 0 && j >= 0) { 
	if (a[i] > b[j]) { 
		a[k--] = a[i--]; 
	} else { 
		a[k--] = b[j--]; 
	} 
	} 
	while (j >= 0) { 
		a[k--] = b[j--]; 
	} 
} 
CODE_END#



H3#@38.	Complexity of sorting algorithm.
img#@http://infopulseukraine.com/Global/Blog/Timsort/img_timsort_1.png


H3#@39.	Quick Sort
img#@http://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gif
CODE_START#
START_SNIPPET
int partition(int arr[], int left, int right)
{
      int i = left, j = right;
      int tmp;
      int pivot = arr[(left + right) / 2];
     
      while (i < = j) {
            while (arr[i] <  pivot)
                  i++;
            while (arr[j] > pivot)
                  j--;
            if (i < = j) {
                  tmp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = tmp;
                  i++;
                  j--;
            }
      };
     
      return i;
}
 
void quickSort(int arr[], int left, int right) {
      int index = partition(arr, left, right);
      if (left <  index - 1)
            quickSort(arr, left, index - 1);
      if (index <  right)
            quickSort(arr, index, right);
}
CODE_END#



H3#@40.	Implement external  merge sort.
External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory (usually a hard drive). External sorting typically uses a sort-merge strategy. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined into a single larger file.

One example of external sorting is the external merge sort algorithm, which sorts chunks that each fit in RAM, then merges the sorted chunks together. For example, for sorting 900 megabytes of data using only 100 megabytes of RAM:

1) Read 100 MB of the data in main memory and sort by some conventional method, like quicksort.
2) Write the sorted data to disk.
3) Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file.
4) Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.)
5) Perform a 9-way merge and store the result in the output buffer. If the output buffer is full, write it to the final sorted file, and empty it. If any of the 9 input buffers gets empty, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available.
6) As we have taken maximum 10MB from  each chunk, we sort 10MB (it could be all 10MB from 1 chunk only) and put that sorted chunk into Output buffer or write it into main memory once all 10MB output buffer is full. Then fill input is get empty by 10MB and it became 80MB from 90MB. SO, fill 10MB buffers from where we got elements for sorting.	

a#@http://www.ashishsharma.me/2011/08/external-merge-sort.html#@Click here for code snippet.

H3#@41.	Check Balanced Parentheses.
CODE_START#
START_SNIPPET
def isBalanced(expr): 
	if len(expr)%2!=0:
		return False 
	opening=set('([{') 
	match=set([ ('(',')'), ('[',']'), ('{','}') ]) 
	stack=[] 
	
	for char in expr: 
		if char in opening: 
			stack.append(char) 
		else: if len(stack)==0: 
			return False 
		lastOpen=stack.pop() 
		if (lastOpen, char) 
			not in match: 
			return False 
return len(stack)==0 
CODE_END#

H3#@42.	There is a building of 100 floors. If an egg drops from the Nth floor or above it will break. If it's dropped from any floor below, it will not break. You're given 2 eggs. Find N, while minimizing the number of drops for the worst case.

H4#@Using The Binary Search Method

Your first instinct (especially if you are a programmer) may be to solve this problem using the binary search method. So, you think that maybe by dividing the "result set" in half each time you will be able to solve the problem and find the threshold floor for the eggs. In this case the "result set" is the floors in the building, so you start at floor 50 since that is half of 100.

Let's say we do start at the 50th floor, then what should we do if the egg breaks? This means that the answer is somewhere between the first and 50th floor. And we would be left with only 1 more egg since we started with 2 eggs. Now if we are following the binary search method, it seems that the next step would be to try dropping the remaining egg from the 25th floor. But what if it breaks at the 25th floor? Then we really don't have an answer to the problem since we have not found the threshold floor for the eggs. Even if it doesn't break and we decide to go to the next floor (which would be half of 25 or 12.5, which is approximately 13), then if it breaks at the 13th floor then we would still not have an answer to the problem.

Clearly the binary search method does not work for us here, because we only have 2 eggs. The binary search method would be good in a scenario where we have an infinite number of eggs, but we now have to change our strategy and find a better solution.

H4#A new solution

Since we have to find the answer with 2 eggs then why not do something like this: we start by dropping one of the eggs on the 10th floor: if it doesn't break then we continue on to the 20th floor, then 30th, 40th… up to 100 in intervals of 10 until the first egg actually breaks. If the egg breaks on the 10th floor then we know that the threshold floor must be either the 10th floor or one of the floors below it – the egg will definitely break on any floor above the 10th floor, so we can eliminate all of the floors above the 10th.

If the egg breaks on the 10th floor…

So, the answer must be between floors 1 through 10. We can take the 2nd egg and drop it from the first floor. If it does not break on the first floor, but it does break on the 2nd floor, then we know that the 2nd floor is the "threshold" floor. And if it doesn't break on any of the floors between 2-8, then we just continue up until the 9th floor, and if it does not break on the 9th floor then we know that the 11th floor is our threshold floor. This will take a maximum of 10 drops to figure out the threshold floor in this instance.

What about the worst case solution? Well, the worst case using this method occurs when the threshold floor is the 100th floor. This means that we use 10 drops to get to the 100th floor, because we start from the 10th floor and go up in intervals of 10 up to the 100th floor, and the first egg will break on the 100th floor. And then we use another 9 drops with the 2nd egg because we have to test floors 90-99 to see if the threshold floor is somewhere in that range. This gives us a total of 19 drops, which is the absolute worst case scenario using this method.

H4#Use the linear search method for this brainteaser

The simple search method we used above is called a linear search – which is simply a sequential search to find a particular value in a list of elements. In this case, the list of elements are floors in a building, and the value we are searching for is the threshold floor in that building for the eggs.

It should be clear to you now that a linear search is indeed necessary with the 2nd egg because we can not risk breaking the 2nd egg before we even find the answer – remember we only have 2 identical eggs and we must find the answer with only 2 eggs. This means that we have some freedom with the 1st egg, and that we can do some interesting work with it. So, now the question is can we improve upon the 19 drops used in the worst case scenario with our approach above?

H4#2 Eggs 100 Floors Puzzle Solution

We want to minimize the number of drops for the worst case, while still using an approach that works well for other scenarios. So, how can we do this? Well, we should rephrase that question and ask ourselves what is really holding us back here? The main reason why it takes such a large number of drops in the worst case with our approach above (19 drops) is because in order to test out the higher floors of the building we have to start at the lower floors of the building, and at that point we have already used a large number of drops just to get to that point.

What we should try to get with our next approach is to try to reduce the worst case scenario by trying to make all possible scenarios take the same number of drops.

What if we tried to reduce the number of drops that would be required with the linear search (with the 2nd egg) after we get to one of the higher floors? This way we counteract the fact that getting to the higher floor took so many drops, and if we use less drops for the linear search we are balancing out the worst case.

Let's try to figure this out using some simple algebra. Suppose we drop an egg from floor x. If the egg breaks, then we would have to go through the previous x-1 floors one by one using a linear search.

But, if the egg doesn't break, in our original algorithm we would go up x floors to find the next floor to test from. Why not just go up x-1 floors instead of x floors? This would save us 1 drop if we have to do a linear search with the 2nd egg whenever the first egg breaks – because we would be doing the linear search from floors x+1 to floor ( (x+1) + (x-1)) instead of floors x+1 to floor (x+1) + x. So, that is 1 less egg drop. This means that the next floor that should be attempted to drop from is x + (x-1) if the egg does not break from floor x. And by the same reasoning the floor after that would be x + (x-1) + (x-2) if the egg does not break on floor x + (x-1).

This would go on to form a series that looks like this:

BOX_START#
START_BOX_CONTENT
x + (x-1) + (x-2) + (x-3) + ... + 1
BOX_END#

The series above is what's called a triangular series which is equal to x(x+1)/2. Because there are 100 floors in the building, we set the sum equal to 100 to solve for x:

BOX_START#
START_BOX_CONTENT
x(x+1)/2 = 100
BOX_END#

When the sum of the series above equals 100, we get x = 13.651, which rounds up to 14. This means that we should start from floor 14 (which is our x) and then move up x-1 (13) floors to floor 27 if the egg doesn't break and then move up x-2 (12) floors to floor 39 and so on if the egg still does not break.

This is the number of drops required as we move up the floors in the building:

 Drop 	 Floor 
#1	14
#2	27
#3	39
#4	50
#5	60
#6	69
#7	77
#8	84
#9	90
#10	95
#11	99
#12	100
2 Eggs 100 Floors Worst Case Solution

The solution for the worst case in this scenario occurs when the threshold floor is floor number 14 – because we will drop the first egg on floor 14, and it will break. Then we have to test floors 1-13 with the 2nd egg to see where the egg breaks again, and the egg will not break on any of those floors. But since the egg broke on the floor 14, we can conclude that the threshold floor is floor number 14.



H3#@43.	There are one hundred closed lockers in a hallway. A man begins by opening all one hundred lockers. Next, he closes every second locker. Then he goes to every third locker and closes it if it is open or opens it if it is closed (e.g., he toggles every third locker). After his one hundredth pass in the hallway, in which he toggles only locker number one hundred, how many lockers are open?
A door n is toggled once for each factor of n, including itself and 1. That is, door 15 is toggled on round 1, 3, 5, and 15.

Question: When would a door be left open?
Answer: A door is left open if the number of factors (x) is odd. You can think about this by pairing factors off as an open and a close. If there's one remaining, the door will be open.

Question: When would x be odd?
Answer: x is odd if n is a perfect square. Here's why: pair n's factors by their complements. For example, if n is 36, the factors are (1, 36), (2, 18), (3, 12), (4, 9), (6, 6). Note that (6, 6) only contributes 1 factor, thus giving n an odd number of factors.


Question: How many perfect squares are there?
Answer: There are 10 perfect squares. You could count them (1, 4, 9, 16, 25, 36, 49, 64, 81, 100), or you could simply realize that you can take the numbers 1 through 10 and square them (1*1, 2*2, 3*3, ..., 10*10).

Therefore, there are 10 lockers open.



H3#@44.	Given a matrix in which each row and each column is sorted, write a method to find an element in it. 
1.	Rows are sorted left to right in ascending order. Columns are sorted top to bottom in ascending order. 
2.	Matrix is of size MxN. 
This algorithm works by elimination. Every move to the left (--col) eliminates all the elements below the current cell in that column. Likewise, every move down eliminates all the elements to the left of the cell in that row.
CODE_START#
START_SNIPPET
boolean FindElem(int[][] mat, int elem, int M, int N) { 
	int row = 0;
	int col = N-1;
	while (row <  M && col >= 0) { 
		if (mat[row][col] == elem) { 
			return true; 
		} else if (mat[row][col] > elem) { 
			col--;
		} else { 
			row++; 
		} 
	} 
	return false; 
} 
CODE_END#



H3#@45.	How to find if two lines intersect in Cartesian plane.
On a Cartesian plane, if two lines do not intersect, they must be parallel with each other. Hence, their slopes must be the same. If their slopes are different, they would intersect. A line is represented as ax+by+c=0 on a Cartesian plane and the slope is given by -a/b Therefore if -a1/b1 != -a2/b2 for two lines, they will intersect.
CODE_START#
START_SNIPPET
public class Line {
    static final double epsilon = 0.000001;
    public double slope;
    public double yintercept;
 
    public Line(double s, double y) {
        slope = s;
        yintercept = y;
    }
 
    public boolean intersect(Line line2) {
        return Math.abs(slope - line2.slope) > epsilon
                || Math.abs(yintercept - line2.yintercept) <  epsilon;
    }
}
CODE_END#
1.	Two lines can be the same. In that case, we assume they intersects (overlap).
2.	We need to consider the floating system in a computer. Never use == to compare two floating numbers.


H3#@46.	Traverse directed graph.
img#@http://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Directed_acyclic_graph.png/180px-Directed_acyclic_graph.png
H4#@Algorithm: Topological Sorting
CODE_START#
START_SNIPPET
L < - Empty list that will contain the sorted elements
S < - Set of all nodes with no incoming edges
while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
if graph has edges then
    return error (graph has at least one cycle)
else 
    return L (a topologically sorted order)
CODE_END#
a#@https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=10&cad=rja&uact=8&ved=0CHsQFjAJ&url=http%3A%2F%2Fcs.fit.edu%2F~dmitra%2FAlgorithms%2Flectures%2FGRAPH.doc&ei=YmwhU5rdJ4j4oATYsoGoDw&usg=AFQjCNHw8a308UUAGVFGukEtUoaME_86ag&sig2=VsWhMlNA4Dndxj-oCEyHxw&bvm=bv.62922401,d.cGU#@Click here to know about Graph

H3#@47.	Find a line to cut two squares in half.
Line should pass through center of both square.
CODE_START#
START_SNIPPET
    private double topLeftX;
    private double topLeftY;
    private double edge;
 
    public Square(double topLeftX, double topLeftY, double edge) {
        super();
        this.topLeftX = topLeftX;
        this.topLeftY = topLeftY;
        this.edge = edge;
    }
 
    Pair< Double> getCenter() {
        return new Pair< Double>(topLeftX + edge / 2, topLeftY - edge / 2);
    }
}
 
public class Line {
    private double slope;
    private double intercept;
 
    public Line(double slope, double intercept) {
        super();
        this.slope = slope;
        this.intercept = intercept;
    }
}
 
public static Line getLine(Square a, Square b) {
    Pair< Double> centerA = a.getCenter();
    Pair< Double> centerB = b.getCenter();
 
    if (centerA.equals(centerB)) {
        return new Line(centerA.getY() / centerA.getX(), 0);
    } else {
        double slope = (centerB.getY() - centerA.getY())
                / (centerB.getX() - centerA.getX());
        double intercept = (centerB.getX() * centerA.getY() - centerA
                .getX() * centerB.getY())
                / (centerB.getX() - centerA.getX());
        return new Line(slope, intercept);
    }
}
CODE_END#

H3#@47.	Clone graph.

	   1
      / \
     /   \
    0 --- 2
         / \
         \_/

CODE_START#
START_SNIPPET
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector< UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        map< UndirectedGraphNode*, UndirectedGraphNode*> chkset;
        queue< UndirectedGraphNode*> chk;
        if (!node) return NULL;
        chk.push(node);
        UndirectedGraphNode *newNode = new UndirectedGraphNode(node->label);
        chkset[node] = newNode;
        while (!chk.empty()) {
            UndirectedGraphNode *curr = chk.front();
            chk.pop();
            for (int i = 0; i <  curr->neighbors.size(); ++i) {
                UndirectedGraphNode *neighbor = curr->neighbors[i];
                if (chkset.count(neighbor)) {
                    chkset[curr]->neighbors.push_back(chkset[neighbor]);
                } else {
                    UndirectedGraphNode *tmp = new UndirectedGraphNode(neighbor->label);
                    chkset[curr]->neighbors.push_back(tmp);
                    chkset[neighbor] = tmp;
                    chk.push(neighbor);
                }
            }
        }
        return newNode;
    }
};
CODE_END#

H3#@48.	Dijkstra's algorithm
CODE_START#
START_SNIPPET
 function Dijkstra(Graph, source):
      for each vertex v in Graph:                                // Initializations
          dist[v]  := infinity ;                                  // Unknown distance function from 
                                                                 // source to v
          previous[v]  := undefined ;                             // Previous node in optimal path
      end for                                                    // from source
      
      dist[source]  := 0 ;                                        // Distance from source to source
      Q := the set of all nodes in Graph ;                       // All nodes in the graph are
                                                                 // unoptimized – thus are in Q
      while Q is not empty:                                      // The main loop
          u := vertex in Q with smallest distance in dist[] ;    // Source node in first case
          remove u from Q ;
          if dist[u] = infinity:
              break ;                                            // all remaining vertices are
          end if                                                 // inaccessible from source
          
          for each neighbor v of u:                              // where v has not yet been 
                                                                 // removed from Q.
              alt := dist[u] + dist_between(u, v) ;
              if alt <  dist[v]:                                  // Relax (u,v,a)
                  dist[v]  := alt ;
                  previous[v]  := u ;
                  decrease-key v in Q;                           // Reorder v in the Queue
              end if
          end for
      end while
      return dist;
end function
CODE_END#


H3#@49.	Write a method which finds the maximum of two numbers You should not use if-else or any other comparison operator.
CODE_START#
START_SNIPPET
getMax(int a, int b) { int c = a - b;
int k = (c >> 31) & 0x1; int max = a - k * c; return max; 
CODE_END#


H3#@50.	Add two number without + operator.
CODE_START#
START_SNIPPET
int Add(int x, int y)
{
    // Iterate till there is no carry  
    while (y != 0)
    {
        // carry now contains common set bits of x and y
        int carry = x & y;  
 
        // Sum of bits of x and y where at least one of the bits is not set
        x = x ^ y; 
 
        // Carry is shifted by one so that adding it to x gives the required sum
        y = carry < <  1;
    }
    return x;
}
CODE_END#

H3#@50.b	Add 1 to a given number without arithmetic operators

CODE_START#
START_SNIPPET
To add 1 to a number x (say 0011000111), we need to flip all the bits after the rightmost 0 bit (we get 0011000000). Finally, flip the rightmost 0 bit also (we get 0011001000) and we are done.


#include
 
int addOne(int x)
{
  int m = 1;
 
  /* Flip all the set bits until we find a 0 */
  while( x & m )
  {
    x = x^m;
    m < < = 1;
  }
 
  /* flip the rightmost 0 bit */
  x = x^m;
  return x;
}  
CODE_END#


H3#@51.	Give a result of two integer array: Given two arrays a1={1,2,3,4} and a2={5,6,7,8}, add the two array and return a new array n={6,9,1,2}
CODE_START#
START_SNIPPET
public static int[] addArray(int[] ar1, int ar2[])
{
int counter1=ar1.length-1;
int counter2=ar2.length-1;
int counter3= (counter1>counter2?counter1:counter2 )+1;
int[] ar3 = new int[counter3+1];
int carry=0;
while(counter3>-1)
{
if(counter1>=0) carry+=ar1[counter1--];
if(counter2>=0) carry+=ar2[counter2--];
ar3[counter3--]=carry%10;
carry /= 10;
}
return ar3;
}
CODE_END#


H3#@52.	Find minimal number of combination: 
For example: the minimal number of coins to make change for 15 out of a set of coins with value 1, 3, 9. is 3.
We can choose two coins with value 3 and a coin with value 9. The number of coins for other choices should be greater than 3.
b#@
i.e.: 
3 -> f(3 - MaxCurrencyBelow(3))+1 -> f(3 - 3) + 1 => f(0)+ 1 =>1
6 -> f(6 - MaxCurrencyBelow(6))+1 -> f(6 - 3) + 1 => f(3)+ 1 => 2
15 -> f(15 - MaxCurrencyBelow(15))+1 -> f(15 - 9) + 1 => f(6)+ 1 => 3
24 -> f(24 - MaxCurrencyBelow(24))+1 -> f(24 - 9) + 1 => f(15)+ 1 => 4


CODE_START#
START_SNIPPET
int GetMinCount(int total, int* coins, int length)
{
    int* counts = new int[total + 1];
    counts[0] = 0;
   
    const int MAX = 0x7FFFFFFF;

    for(int i = 1; i < = total; ++ i)
    {
        int count = MAX;
        for(int j = 0; j <  length; ++ j)
        {
            if(i - coins[j] >= 0 && count > counts[i - coins[j]])
                count = counts[i - coins[j]];
        }

        if(count <  MAX)
            counts[i] = count + 1;
        else
            counts[i] = MAX;
    }

    int minCount = counts[total];
    delete[] counts;

    return minCount;
}
CODE_END#

H3#@53.	Edit Distance.
The words `computer' and `commuter' are very similar, and a change of just one letter, p->m will change the first word into the second. 
The word `sport' can be changed into `sort' by the deletion of the `p', or equivalently, `sort' can be changed into `sport' by the insertion of `p'.
The edit distance of two strings, s1 and s2, is defined as the minimum number of point mutations required to change s1 into s2, where a point mutation is one of:
1. change a letter,
2. insert a letter or
3. delete a letter
img#@http://www.quretec.com/u/vilo/edu/2005-06/Text_Algorithms/L5_Edit/Edit_dist_diagonal_def.png
CODE_START#
START_SNIPPET
int getEditDistance(char* str1, char* str2, int** distances, int len1, int len2)
{
    for(int i = 0; i <  len2 + 1; ++ i)
        distances[i][0] = i;
    for(int j = 0; j <  len1 + 1; ++ j)
        distances[0][j] = j;

    for(int i = 1; i <  len2 + 1; ++ i)
    {
        for(int j = 1; j <  len1 + 1; ++ j)
        {
            if(str1[j - 1] == str2[i - 1])
                distances[i][j] = distances[i - 1][j - 1];
            else
            {
                int deletion = distances[i][j - 1] + 1;
                int insertion = distances[i - 1][j] + 1;
                int substitution = distances[i - 1][j - 1] + 1;
                distances[i][j] = min(deletion, insertion, substitution);
            }
        }
    }

    return distances[len2][len1];
}
CODE_END#

H3#@54.	Dynamic Programming on Stolen Values.
There are n houses built in a line, each of which contains some value in it. A thief is going to steal the maximal value in these houses, but he cannot steal in two adjacent houses because the owner of a stolen house will tell his two neighbors on the left and right side. What is the maximal stolen value?

For example, if there are four houses with values {6, 1, 2, 7}, the maximal stolen value is 13 when the first and fourth houses are stolen.

We will maintain two values at each element.
1. If we follow alternate sequence for current element. 
2. If we follow alternate sequence for next element. 
Let me simplify above confusing statement.

	6		1		2			7				9
	6	    6	   6,8(6+2)     8,13(6+7)       13,17(8+9)

CODE_START#
START_SNIPPET
int maxStolenValue(const vector< int>& values)
{
    int length = values.size();
    if(length == 0)
        return 0;

    int value1 = values[0];
    if(length == 1)
        return value1;

    int value2 = max< int>(values[0], values[1]);
    if(length == 2)
        return value2;

    int value;
    for(int i = 2; i <  length; ++i)
    {
        value = max< int>(value2, value1 + values[i]);
        value1 = value2;
        value2 = value;
    }

    return value;
}

CODE_END#

H3#@54.	A man is running up a staircase with n steps, and can go either 1 steps, 2 steps, or 3 steps at a time. Now write a program to count how many possible ways the child can run the stairs.

CODE_START#
START_SNIPPET
public static int countDP(int n, int[] map) {
 if (n< 0)
   return 0;
 else if (n==0)
   return 1;
 else if (map[n]>-1)
   return map[n];
 else {
    map[n] = countDP(n-1, map) + countDP(n-2, map) + countDP(n-3, map);
    return map[n]; }
 }
CODE_END#

Okay, here is what the code does.

 `if (n< 0)`
    `return 0;`
If there aren't enough steps remaining, then don't count it. For instance, if there are two steps remaining, but the user is trying to take three steps, then it does not count as a possible combination.

else if (n==0)  return 1;

If the number of steps remaining matches the number of available steps the user is trying to take, it is a possible combination. So, return a 1 because this is a possible combination and should be added to the total number of valid combinations.

else if (map[n]>-1)  return map[n];

Here is the dynamic programming part. Assume that the all the values in the array had a value of -1. So, if the number is greater than -1, it has already been solved for, so return the total number of combinations from step number n instead of resolving it.

`map[n] = countDP(n-1, map) + countDP(n-2, map) + countDP(n-3, map);`
return map[n]; }

Finally, this part solves the code. The number of possible combinations is equal to the number of possible combinations the user can get if he takes 1 step + the number of possible combinations the user can get if he takes 2 steps + the number of possible combinations the user can get if he takes three steps.

An example, suppose there are 5 steps

BOX_START#
START_BOX_CONTENT
/The number of solutions from the fifth step

countDp(5) = countDp(4)+countDp(3)+countDp(2);

//Number of solutions from the fourth step

countDP(4) = countDp(3)+countDp(2)+countDp(1);

//Number of solutions from the third step

countDp(3) = countDp(2)+countDp(1)+countDp(0);
//Number of solutions from the second step
countDp(2) = countDp(1)+countDp(0)+countDp(-1);
//Number of solutions from the first step
countDp(1) = countDp(0) + countDp(-1)+countDp(-2);
//Finally, base case
countDp(0) = 1;

countDp(-1)= 0;
countDp(-2)= 0;
countDp(1) = 1+0+0 = 1;
countDp(2) = 1+1+0 = 2;  //Dynamic programming: did not have to resolve for countDp(1), instead looked up the value in map[1]
countDp(3) = 2+1+1 = 4;  //Dynamic programming, did not have to solve for countDp(1), countDp(2), instead looked up value in map[1] and map[2]
countDp(4) = 4+2+1=7 //Dynamic programming, did not have to solve for CountDp(3),CountDp(2), CountDp(1), just looked them up in map[3],map[2],map[1]
countDp(5)=  2+4+7=13 //Dynamic programming, just used map[4]+map[3]+map[2]
BOX_END#


H3#@54.	Longest Increasing Subsequence.
he longest increasing subsequence problem is a dynamic programming problem that calculates the length of a non-contiguous subsequence from a given sequence. For example, given the sequence: 
0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15
A subsequence is 0,4,2,1,5. An increasing subsequence is 0,4,10,14,15. The question is to find the length of the longest increasing subsequence, which has size 6 (0, 2, 6, 9, 13, 15). Note that the sequence might not be unique, but you need to find the length of the longest subsequence. 

i.e.:
0,8,4,12,2
1.	Every element will get default weight = 1.
2. It can also gets additional weight from its latest previous elements if they are smaller and who has highest value then it. It starts from 1st element.
0=1
8=w(0)+1=1+1=2
4=w(0)+1=1+1=2
12=w(4)+1=3
2=w(0)+1=2
CODE_START#
START_SNIPPET
public static int increasingSubsequence(int[]seq){
    int[]L=new int[seq.length];
    L[0]=1;
    for(int i=1;i< L.length;i++){
      int maxn=0;
      for(int j=0;j< i;j++){
        if(seq[j]< seq[i]&&L[j]>maxn){
          maxn=L[j];
        }
      }
      L[i]=maxn+1;
    }
    int maxi=0;
    for(int i=0;i< L.length;i++){
      if(L[i]>maxi){
        maxi=L[i];
      }
    }
    return(maxi);
}
CODE_END#

H3#@54.	Find longest common substring
i.e.:
XYZABC
 YZA

L[0,0]=0,[0,1]=0,l[0,2]=0
L[1,0]=1,[1,1]=0,l[1,2]=0
L[2,0]=0,[2,1]=L[1,0]+1=2,l[0,2]=0

CODE_START#
START_SNIPPET
function LCSubstr(S[1..m], T[1..n])
    L := array(1..m, 1..n)
    z := 0
    ret := {}
    for i := 1..m
        for j := 1..n
            if S[i] == T[j]
                if i == 1 or j == 1
                    L[i,j] := 1
                else
                    L[i,j] := L[i-1,j-1] + 1
                if L[i,j] > z
                    z := L[i,j]
                    ret := {S[i-z+1..i]}
                elif L[i,j] == z
                    ret := ret ∪ {S[i-z+1..i]}
            else 
                L[i,j] := 0
    return ret
CODE_END#

H3#@55.	Stack with Function min(). pop(), push(), min() should have complexity o(1).
Supposing that we are going to push a number value into a stack with minimum number min. If value is greater than or equal to the min, it is pushed directly into data stack. If it is less than min, we push 2*value -min, and update min as value since a new minimum number is pushed. How about to pop? We pop it directly if the top of data stack (it is denoted as top) is greater than or equal to min. Otherwise the number top is not the real pushed number. The real pushed number is stored is min. After the current minimum number is popped, we need to restore the previous minimum number, which is 2*min-top.

H3#@56.	Given an array of numbers, find out if 3 of them add up to 0.
CODE_START#
START_SNIPPET
Sort the array // O(nlogn)

for each i from 1 to len(array) - 1
  iter = i + 1
  reviter = len(array) - 1
  while iter <  reviter
    tmp = array[iter] + array[reviter] + array[i]
    if  tmp > 0
       reviter--
    else if tmp <  0
       iter++
    else 
      return true
return false
CODE_END#

H3#@57.	Diameter of Binary Tree or longest path of a Binary tree.
There are three cases to consider when trying to find the longest path between two nodes in a binary tree (diameter):

The longest path passes through the root,
The longest path is entirely contained in the left sub-tree,
The longest path is entirely contained in the right sub-tree.
The longest path through the root is simply the sum of the heights of the left and right sub-trees + 1 (for the root node), and the other two can be found recursively:
CODE_START#
START_SNIPPET
public static int getDiameter(BinaryTreeNode root) {        
    if (root == null)
        return 0;

    int rootDiameter = getHeight(root.getLeft()) + getHeight(root.getRight()) + 1;
    int leftDiameter = getDiameter(root.getLeft());
    int rightDiameter = getDiameter(root.getRight());

    return Math.max(rootDiameter, Math.max(leftDiameter, rightDiameter));
}

public static int getHeight(BinaryTreeNode root) {
    if (root == null)
        return 0;

    return Math.max(getHeight(root.getLeft()), getHeight(root.getRight())) + 1;
}
CODE_END#

H3#@58.	Transform a binary tree to a left child right sibling tree?
CODE_START#
START_SNIPPET
BST * siblingsTransform(BST *root) 
{ 
if(root == NULL) 
return NULL; 
siblingsTransform(root->left); 
siblingsTransform(root->right); 
if(root->left !=NULL) 
{ 
root->left ->right = root->right; 
root->right = NULL; 
} 
else 
{ 
root->left = root->right; 
} 
return root; 
}
CODE_END#

H3#@59.	how to merge two BST's efficiently?
CODE_START#
START_SNIPPET
H4#@Flattening a BST into a sorted list is O(N)
1. It's just "in-order" iteration on the whole tree.
2. Doing it for both is O(n1+n2)
H4#@Merging two sorted lists is into one sorted list is O(n1+n2).
1. Keep pointers to the heads of both lists
2. Pick the smaller head and advance its pointer
3. This is how the merge of merge-sort works
H4#@Creating a perfectly balanced BST from a sorted list is O(N)
1. The value at the middle would be the root, and recurse.
2. In our case the sorted list is of size n1+n2. so O(n1+n2)
3. The resulting tree would be the conceptual BST of binary searching the list
Three steps of O(n1+n2) result in O(n1+n2)

For n1 and n2 of the same order of magnitude, that's better than O(n1 * log(n2))
CODE_END#

H3#@60.	Longest palindrome
CODE_START#
START_SNIPPET
string expandAroundCenter(string s, int c1, int c2) {
  int l = c1, r = c2;
  int n = s.length();
  while (l >= 0 && r < = n-1 && s[l] == s[r]) {
    l--;
    r++;
  }
  return s.substr(l+1, r-l-1);
}
 
string longestPalindromeSimple(string s) {
  int n = s.length();
  if (n == 0) return "";
  string longest = s.substr(0, 1);  // a single char itself is a palindrome
  for (int i = 0; i <  n-1; i++) {
    string p1 = expandAroundCenter(s, i, i);
    if (p1.length() > longest.length())
      longest = p1;
 
    string p2 = expandAroundCenter(s, i, i+1);
    if (p2.length() > longest.length())
      longest = p2;
  }
  return longest;
}
CODE_END#

H3#@61.	Find square root.

CODE_START#
START_SNIPPET
	# using Babylonian method, if N is number and x is estimate, replace x by (x+N/x)/2;

import math;
def main():
        # N will contain the number whose square root needs to be found.
        N=466;
        # initial estimate of square root
        x=N/2.0;
        x += 0.0;
        precision = 0.000003;
        while True:
                if math.fabs(x*x-N) <  precision: break;
                x = (x+N/x)/2


        print "Given Number = ",N;
        print "Approx Square Root = ", x;
        print "Square of approx square root = ", x*x;


main();
CODE_END#

H#@62.	For a given node in binary search tree find a next largest number in search tree.
CODE_START#
START_SNIPPET
public static void  findNextLargest(TreeNode node,TreeNode target){
		TreeNode temp=null;
		if(target.right!=null){
			temp = target.right;
			while(temp.left!=null){
				temp = temp.left;
			}
			System.out.println(temp.val);
			return;
		}
		
		while(node!=null){
			if(target.val <  node.val){
				temp = node;
				node = node.left;
			}else if(target.val > node.val){
				node = node.right;
			}else
				break;
		}
		if(temp!=null)
                         System.out.println(temp.val);
		return;
		
	}
CODE_END#

H3#@63.	Combine String
i.e.: S1=aaf, S2=abc, S3=aabafc

We will use recursion to solve the problem, but first we check whether the length of str1 plus str2 equals to the length of str3. If not, then str3 can’t be a valid shuffle since it contains extra characters, so we return false immediately.

So, we need to perform dynamic programming and cache the already evaluated results to avoid precomputation. Once we see that two input strings don’t produce a valid shuffle, we cache this information (if they do produce a valid shuffle then we’re done and return True, so no need to cache). In the beginning of the function we will check whether we evaluated the given input strings before trying to compute again.  If we did, then we won’t try again and immediately return False. Here is the code with caching:

CODE_START#
START_SNIPPET
def isShuffle2(str1, str2, str3, cache=set()):
	if (str1, str2) in cache: 
		return False
	
	if len(str1)+len(str2)!=len(str3): 
		return False   
	
	if not str1 or not str2 or not str3:
		if str1+str2==str3:
			return True 
		else: 
			return False
	
	if str1[0]!=str3[0] and str2[0]!=str3[0]: 
		return False
		
		
	if str1[0]==str3[0] and isShuffle2(str1[1:], str2, str3[1:], cache):
		return True
	if str2[0]==str3[0] and isShuffle2(str1, str2[1:], str3[1:], cache): 
		return True 
	
	
	cache.add( (str1, str2) )
	
	return false;
	
	
	
CODE_END#

H3#@HashTable

CODE_START#
START_SNIPPET
public class Hashtable< K,V>
    extends Dictionary< K,V>
    implements Map< K,V>, Cloneable, java.io.Serializable {

    private transient Entry< K,V>[] table;
    private transient int count;
    private int threshold;
    private float loadFactor;

	 public Hashtable(int initialCapacity, float loadFactor) {
        if (initialCapacity <  0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        if (loadFactor < = 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal Load: "+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        table = new Entry[initialCapacity];
        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        initHashSeedAsNeeded(initialCapacity);
    }
	
	 public Hashtable() {
        this(11, 0.75f);
    }
	
	 public synchronized int size() {
        return count;
    }
	
	public synchronized boolean isEmpty() {
        return count == 0;
    }
	
	public synchronized boolean contains(Object value) {
        if (value == null) {
            throw new NullPointerException();
        }

        Entry tab[] = table;
        for (int i = tab.length ; i-- > 0 ;) {
            for (Entry< K,V> e = tab[i] ; e != null ; e = e.next) {
                if (e.value.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }
	
	 public synchronized boolean containsKey(Object key) {
        Entry tab[] = table;
        int hash = hash(key);
        int index = (hash & 0x7FFFFFFF) % tab.length;
        for (Entry< K,V> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                return true;
            }
        }
        return false;
    }
	
	
	public synchronized V get(Object key) {
        Entry tab[] = table;
        int hash = hash(key);
        int index = (hash & 0x7FFFFFFF) % tab.length;
        for (Entry< K,V> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                return e.value;
            }
        }
        return null;
    }
	
	 protected void rehash() {
        int oldCapacity = table.length;
        Entry< K,V>[] oldMap = table;

        // overflow-conscious code
        int newCapacity = (oldCapacity < <  1) + 1;
        if (newCapacity - MAX_ARRAY_SIZE > 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        Entry< K,V>[] newMap = new Entry[newCapacity];

        modCount++;
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        boolean rehash = initHashSeedAsNeeded(newCapacity);

        table = newMap;

        for (int i = oldCapacity ; i-- > 0 ;) {
            for (Entry< K,V> old = oldMap[i] ; old != null ; ) {
                Entry< K,V> e = old;
                old = old.next;

                if (rehash) {
                    e.hash = hash(e.key);
                }
                int index = (e.hash & 0x7FFFFFFF) % newCapacity;
                e.next = newMap[index];
                newMap[index] = e;
            }
        }
    }

	 /**
     * Hashtable bucket collision list entry
     */
    private static class Entry< K,V> implements Map.Entry< K,V> {
        int hash;
        final K key;
        V value;
        Entry< K,V> next;

        protected Entry(int hash, K key, V value, Entry< K,V> next) {
            this.hash = hash;
            this.key =  key;
            this.value = value;
            this.next = next;
        }

        protected Object clone() {
            return new Entry< >(hash, key, value,
                                  (next==null ? null : (Entry< K,V>) next.clone()));
        }

        // Map.Entry Ops

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            if (value == null)
                throw new NullPointerException();

            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry< ?,?> e = (Map.Entry)o;

            return key.equals(e.getKey()) && value.equals(e.getValue());
        }

        public int hashCode() {
            return (Objects.hashCode(key) ^ Objects.hashCode(value));
        }

        public String toString() {
            return key.toString()+"="+value.toString();
        }
    }

	
	
}
CODE_END#

H3#@65.	Build tree from ancestor tree.
a#@http://www.ritambhara.in/build-binary-tree-from-ancestor-matrics/#@Click here.


H3#@66.	Implement inorder traversal without recurssion.
H4#@1. Without using stack (Morris traversal)
1. Initialize current as root
2. While current is not NULL
   If current does not have left child
      a) Print current’s data
      b) Go to the right, i.e., current = current->right
   Else
      a) Make current as right child of the rightmost node in current's left subtree
      b) Go to this left child, i.e., current = current->left

Steps:
1. Take a node and copy it to the -> immediate left predecessors's right most child's right
2. Move to Left node and follow 1
3. If left is null-> print current node and move to right (which is it's parent node and that parent node's left child is again the current node->check diagram)

	  
Although the tree is modified through the traversal, it is reverted back to its original shape after the completion.Unlike Stack based traversal, no extra space is required for this traversal.

CODE_START#
START_SNIPPET

Actual:
				10
			6		12
		4	  7

After 2 iteration:
				10
			6		12
		4	  7
		   6	10

(Point 4's left to its parent-6 and still 6 has left node as 4 (so, if current =4 and pre = current.right which 6, then pre.left = current)

/* A binary tree tNode has data, pointer to left child and a pointer to right child */
struct tNode
{
   int data;
   struct tNode* left;
   struct tNode* right;
};
 
/* Function to traverse binary tree without recursion and without stack */
void MorrisTraversal(struct tNode *root)
{
  struct tNode *current,*pre;
 
  if(root == NULL)
     return; 
 
  current = root;
  while(current != NULL)
  {
    if(current->left == NULL)
    {
      printf(" %d ", current->data);
      current = current->right;
    }
    else
    {
      /* Find the inorder predecessor of current */
      pre = current->left;
      while(pre->right != NULL && pre->right != current)
        pre = pre->right;
 
      /* Make current as right child of its inorder predecessor */
      if(pre->right == NULL)
      {
        pre->right = current;
        current = current->left;
      }
 
      /* Revert the changes made in if part to restore the original
        tree i.e., fix the right child of predecssor */
      else
      {
        pre->right = NULL;
        printf(" %d ",current->data);
        current = current->right;
      } /* End of if condition pre->right == NULL */
    } /* End of if condition current->left == NULL*/
  } /* End of while */
}
 
/* Driver program to test above functions*/
int main()
{
 
  /* Constructed binary tree is
            1
          /   \
        2      3
      /  \
    4     5
  */
  struct tNode *root = newtNode(1);
  root->left        = newtNode(2);
  root->right       = newtNode(3);
  root->left->left  = newtNode(4);
  root->left->right = newtNode(5); 
 
  MorrisTraversal(root);
 
  getchar();
  return 0;
}
CODE_END#

H4#@With stack: Inorder,Preorder, PostOrder
Depth-first[edit]
See also: Depth-first search
There are three types of depth-first traversal: pre-order,[1] in-order,[1] and post-order.[1] For a binary tree, they are defined as operations recursively at each node, starting with the root node as follows:

Pre-order[edit]
Visit the root.
Traverse the left subtree.
Traverse the right subtree.
In-order (symmetric)[edit]
Traverse the left subtree.
Visit root.
Traverse the right subtree.
Post-order[edit]
Traverse the left subtree.
Traverse the right subtree.
Visit the root.
b#@
H4#@inorder
img#@http://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png
H4#@Preporder
img#@http://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png
H4#@PostOrder
img#@http://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png
b#@
CODE_START#
START_SNIPPET
/* Inorder traversal without using recursion */
void printInorder(struct node *root)
{
  struct node *temp;
  if(root == NULL)
    return;
  // Push all node onto the stack
  while(root != NULL)
  {
    push(root);
    root = root->left;
  }
  while(top != -1)
  {
    temp = pop();
    printf("%c \t", temp->data);
    temp = temp->right;
    while(temp != NULL)
    {
       push(temp);
       temp = temp->left;
    }
  }
  printf("top inorder : %d\n", top);
}
/* Pre-order traversal without using recursion */
void printPreorder(struct node *root)
{
  struct node *temp;
  if(root == NULL)
    return 0;
  while(root != NULL)
  {
     printf("%c \t", root->data);
     push(root);
     root = root->left;
  }
  while(top != -1)
  {
     temp = pop();
     temp = temp->right;
     while(temp != NULL)
     {
        printf("%c\t", temp->data);
        push(temp);
        temp= temp->left;
     }
  }
}
/* Post-order traversal without using recursion */
void printPostorder(struct node *root)
{
  struct node *temp;
  if(root == NULL)
    return 0;
  while(root != NULL)
  {
     push(root);
     root = root->left;
  }
  while(top != -1)
  {
     temp = pop();
     push(temp);
     //printf("%c %d\n", temp->data, temp->visited);
     temp = temp->right;
     
     while(temp != NULL && temp->visited == 0)
     {
          temp->visited = 1;
          push(temp);
          temp= temp->left;
          
     } 
     
     temp = pop();
     printf("%c\t", temp->data);   
  }
}
CODE_END#


H3#@66.	How to check whether given number is prime or not
Given an input number n, check whether any integer m from 2 to n − 1 divides n. If n is divisible by any m then n is composite, otherwise it is prime.

However, rather than testing all m up to n − 1, it is only necessary to test m up to root of n. if n is composite then it can be factored into two values, at least one of which must be less than or equal to root of n.

The efficiency can also be improved by skipping all even m except 2, since if any even number divides n then 2 does.
 It can be improved further by observing that all primes are of the form 6k ± 1, with 2 and 3 being the only exceptions. 

This is because all integers can be expressed as (6k + i) for some integer k and for i = −1, 0, 1, 2, 3, or 4; 2 divides (6k + 0), (6k + 2), (6k + 4); and 3 divides (6k + 3). 

So a more efficient method is to test if n is divisible by 2 or 3, then to check through all the numbers of form 6k ± 1 . This is 3 times as fast as testing all m.

H3#@67.	Searching an Element in a Rotated Sorted Array
b#@
img#@http://3.bp.blogspot.com/_UElib2WLeDE/S8TAqqC2_4I/AAAAAAAACII/BJ11UEyVDp0/s320/rotatedarray.PNG
CODE_START#
START_SNIPPET
int rotated_binary_search(int A[], int N, int key) {
  int L = 0;
  int R = N - 1;
 
  while (L < = R) {
    // Avoid overflow, same as M=(L+R)/2
    int M = L + ((R - L) / 2);
    if (A[M] == key) return M;
 
    // the bottom half is sorted
    if (A[L] < = A[M]) {
      if (A[L] < = key && key <  A[M])
        R = M - 1;
      else
        L = M + 1;
    }
    // the upper half is sorted
    else {
      if (A[M] <  key && key < = A[R])
        L = M + 1;
      else
        R = M - 1;
    }
  }
  return -1;
}
CODE_END#

H3#@68.	Find two non repeating elements in the given array which contains all repeated elements except two
i.e.: a= {4,4,10,7}
XOR of a[..] -> it will give us only difference of bits between 10 and 7. It means result(5=0101) is a combination of unique set bit from each numbers (10,7).
10-1010
07-0111
-------
05-0101
SO, now let's take any set bit from result(5)-> let's take right most set bit-> 0001 =x
1.	X&10=0 and X&7=1 because right most bit is set only in 7 and not 10.
2. Prepare two sets, one set will have numbers which has X bit set and other set will not set
3. In that way, 7 will go in 1 bucket and 10 will go in other bucket
4. Now, take XOR of all numbers in a given bucket, it will give you unique number.

Solution:
Let x and y be the non-repeating elements we are looking for and arr[] be the input array. First calculate the XOR of all the array elements.

     xor = arr[0]^arr[1]^arr[2].....arr[n-1]
All the bits that are set in xor will be set in one non-repeating element (x or y) and not in other. So if we take any set bit of xor and divide the elements of the array in two sets – one set of elements with same bit set and other set with same bit not set. By doing so, we will get x in one set and y in another set. Now if we do XOR of all the elements in first set, we will get first non-repeating element, and by doing same in other set we will get the second non-repeating element.

Let us see an example.
   arr[] = {2, 4, 7, 9, 2, 4}
1) Get the XOR of all the elements.
     xor = 2^4^7^9^2^4 = 14 (1110)
2) Get a number which has only one set bit of the xor.
   Since we can easily get the rightmost set bit, let us use it.
     set_bit_no = xor & ~(xor-1) = (1110) & ~(1101) = 0010
   Now set_bit_no will have only set as rightmost set bit of xor.
3) Now divide the elements in two sets and do xor of
   elements in each set, and we get the non-repeating
   elements 7 and 9. 

CODE_START#
START_SNIPPET
#include 
#include 

/* This finction sets the values of *x and *y to nonr-epeating
 elements in an array arr[] of size n*/
void get2NonRepeatingNos(int arr[], int n, int *x, int *y)
{
  int xor = arr[0]; /* Will hold xor of all elements */
  int set_bit_no;  /* Will have only single set bit of xor */
  int i;
  *x = 0;
  *y = 0; 

  /* Get the xor of all elements */
  for(i = 1; i <  n; i++)
   xor ^= arr[i];

  /* Get the rightmost set bit in set_bit_no */
  set_bit_no = xor & ~(xor-1);

  /* Now divide elements in two sets by comparing rightmost set
   bit of xor with bit at same position in each element. */
  for(i = 0; i <  n; i++)
  {
    if(arr[i] & set_bit_no)
     *x = *x ^ arr[i]; /*XOR of first set */
    else
     *y = *y ^ arr[i]; /*XOR of second set*/
  }
}     

/* Driver program to test above function */
int main()
{
  int arr[] = {2, 3, 7, 9, 11, 2, 3, 11};
  int *x = (int *)malloc(sizeof(int));
  int *y = (int *)malloc(sizeof(int));
  get2NonRepeatingNos(arr, 8, x, y);
  printf(" The non-repeating elements are %d and %d", *x, *y);
  getchar();
}


Time Complexity: O(n)
Auxiliary Space: O(1)

Explanation :

XOR of two same numbers results in 0(000..00)

XOR of two different numbers x and y results in a number which contains set bits at the places where x and y differ. So if x and y are 10...0100 and 11...1001, then result would be 01...1101.

So the idea is to XOR all the elements in set.In the result xor, all repeating elements would nullify each other. The result would contain the set bits where two non-repeating elements differ.

Now, if we take any set bit of the result xor and again do XOR of the subset where that particular bit is set, we get the one non-repeating element.And for other non-repeating element we can take the subset where that particular bit is not set.

We have chosen the rightmost set bit of the xor as it is easy to find out.
CODE_END#

H3#@69.	Heap Sort
1.	In Heap sort, parent is always bigger than its childs (2i+1,2i+2).
2.	While insertion we always make sure that parent has bigger value and if not then we exchange the child with its parent and then again check parent and its parent and exchange and so on..
b#@
img#@http://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif
b#@
CODE_START#
START_SNIPPET
public class HeapSort 
{
    private static int[] a;
    private static int n;
    private static int left;
    private static int right;
    private static int largest;

    
    public static void buildheap(int []a){
        n=a.length-1;
        for(int i=n/2;i>=0;i--){
            maxheap(a,i);
        }
    }
    
    public static void maxheap(int[] a, int i){ 
        left=2*i;
        right=2*i+1;
        if(left < = n && a[left] > a[i]){
            largest=left;
        }
        else{
            largest=i;
        }
        
        if(right < = n && a[right] > a[largest]){
            largest=right;
        }
        if(largest!=i){
            exchange(i,largest);
            maxheap(a, largest);
        }
    }
    
    public static void exchange(int i, int j){
        int t=a[i];
        a[i]=a[j];
        a[j]=t; 
        }
    
    public static void sort(int []a0){
        a=a0;
        buildheap(a);
        
        for(int i=n;i>0;i--){
            exchange(0, i);
            n=n-1;
            maxheap(a, 0);
        }
    }
    
    public static void main(String[] args) {
        int []a1={4,1,3,2,16,9,10,14,8,7};
        sort(a1);
        for(int i=0;i< a1.length;i++){
            System.out.print(a1[i] + " ");
        }
    }
}

OUTPUT :

1 2 3 4 7 8 9 10 14 16 
CODE_END#

H3#@70.	Check if Array elements are consecutive
{3,4,5,6}=true, {3,4,5,5,7}=false
1.	Traverse: keep track of min,max, and sum, and of course size of array
if((max-min+1)==size && sum==calculatedSum){return true;}
Calculated sum = n (a1 + an) /2 
n = number of terms (or how many numbers there are) 
a1 = the first number 
a2 = the last number 
i.e.: 4*(3+6)/2 = 18, 5*(3+7)/2=25

H3#@71.	Implement Queue using stack
CODE_START#
START_SNIPPET
class StackQueue< T> {
    Stack< T> s1 = new Stack< T>();
    Stack< T> s2 = new Stack< T>();

    void push(T obj) {
		if(!s2.isEmpty()){
			while(!s2.isEmpty()){
				s1.push(s2.pop());
			}
		}
        s1.push(obj);
    }

    T pop() {
        if (s2.isEmpty()) {
            if (s1.isEmpty()) {
                return null;
            }
            while (!s1.isEmpty()) {
                s2.push(s1.pop());
            }
        }
        return s2.pop();
    }
}
CODE_END#

H3#@72.	Find the pair from an sorted array whose difference is x
CODE_START#
START_SNIPPET
i=0,j=1;
while((i!=n-1) or j!=n)
{

  /*compare difference of a[j] and a[i]*/
  if( (a[j]-[a[i]])>x ) {
    i++;j++;
  }

  else if( (a[j]-a[i]) {
    j++;
  }

  else 
  {
  /*SOLUTION*/
  map.add(new Pair(i,j));
  i++;
  }

}
CODE_END#

H3#@73.	Finding the missing integer in a file of 4 billion integers
XOR all values in the file together (value 1)
Find the lowest and highest numbers at the same time
XOR all values from lowest up to highest (value 2)
XOR the two values (value 1 and value 2) together to find the missing value
This method will not detect if the missing value is the lowest value - 1 or highest value + 1, for instance, if the file is supposed to hold 1..10, but is missing 10 or 1, then the above approach will not find it.

This solution is O(2n) (we loop the numbers twice), which translates to O(n).
CODE_START#
START_SNIPPET
void Main()
{
    var input = new[] { 1, 2, 3, 4, 5, 6, 8, 9, 10 };
    MissingXOR(input).Dump("xor");
    MissingADD(input).Dump("add");
}

public static int MissingXOR(int[] input)
{
    var lowest = input[0];
    var highest = input[0];
    int xor = 0;
    foreach (var value in input)
    {
        lowest = Math.Min(lowest, value);
        highest = Math.Max(highest, value);
        xor ^= value;
    }
    int requiredXor = 0;
    for (int index = lowest; index < = highest; index++)
        requiredXor ^= index;

    return xor ^ requiredXor;
}

public static int MissingADD(int[] input)
{
    var lowest = input[0];
    var highest = input[0];
    int sum = 0;
    foreach (var value in input)
    {
        lowest = Math.Min(lowest, value);
        highest = Math.Max(highest, value);
        sum += value;
    }
    var sumToHighest = (highest * (highest + 1)) / 2;
    var sumToJustBelowLowest = (lowest * (lowest - 1)) / 2;
    int requiredSum =  sumToHighest - sumToJustBelowLowest;
    return requiredSum - sum;
}
CODE_END#

H3#@74.	Find whether given tree is a subtree or not
Given two binary trees T1 and T2 which store character data, duplicates allowed. You have to devise an algorithm to decide whether the T2 is a subtree of T1. T1 has millions of nodes and T2 has hundreds of nodes.

CODE_START#
START_SNIPPET
check( node t1 , node t2 ) 
{
   if ( t1->data == t2->data)
  {
     return check( t1->left , t2->left ) && check(t1->right, t2->right) ; 
  }
  else
  {
     return check(t1->left , t2) || check(t1->right , t2); 
  }
}
CODE_END#
	
H3#@75.	Find a line which passes the most number of points.
We have a bunch of line segments, represented as a slope and y-intercept, and we want to find the most common slope and y-intercept. 
How can we find the most common one? This is really no different than the old "find the most common number in a list of numbers" problem. 
We just iterate through the lines segments and use a hash table to count the number of times we've seen each line.
CODE_START#
START_SNIPPET
public static Line findBestLine(GraphPoint[] points) {
    Line bestLine = null;
    HashMap< Line, Integer> line_count = new HashMap< Line, Integer>();
    for (int i = 0; i <  points.length; i++) {
        for (int j = i + 1; j <  points.length; j++) {
            Line line = new Line(points[i], points[j]);
            if (!line_count.containsKey(line)) {
                line_count.put(line, 0);
            }
            line_count.put(line, line_count.get(line) + 1);
            if (bestLine == null
                    || line_count.get(line) > line_count.get(bestLine)) {
                bestLine = line;
            }
        }
    }
    return bestLine;
}
 
public class Line {
    private static double epsilon = .0001;
    public double slope;
    public double intercept;
    private boolean infinite_slope = false;
 
    public Line(GraphPoint p, GraphPoint q) {
        if (Math.abs(p.x - q.x) > epsilon) { // if x's are different
            slope = (p.y - q.y) / (p.x - q.x); // compute slope
            intercept = p.y - slope * p.x; // y intercept from y=mx+b
        } else {
            infinite_slope = true;
            intercept = p.x; // x-intercept, since slope is infinite
        }
    }
 
    public boolean isEqual(double a, double b) {
        return (Math.abs(a - b) <  epsilon);
    }
 
    @Override
    public int hashCode() {
        int sl = (int) (slope * 1000);
        int in = (int) (intercept * 1000);
        return sl | in;
    }
 
    @Override
    public boolean equals(Object o) {
        Line l = (Line) o;
        if (isEqual(l.slope, slope) && isEqual(l.intercept, intercept)
                && (infinite_slope == l.infinite_slope)) {
            return true;
        }
        return false;
    }
}
CODE_END#


H3#@70.	Implement Address Book using Trie tree.
Trie is an ordered tree data structure that uses strings as keys. Unlike Binary Trees, Tries do not store keys associated with the node. The key is actually determined based on the position of the node on the tree. Any descendants of a node shares a common prefix of the key string associated with that node. Hence, trie is also called as Prefix Tree. The word "trie" comes from Retrieval, and it is pronounced as "try". 

1. Node: Represents a single tree node;
2. NodeCollection: Represents the children of a node;
3. Trie: Trie implementation to insert and search nodes.
b#@
img#@http://www.codeproject.com/KB/recipes/PhoneDirectory/Trie.jpg

CODE_START#
START_SNIPPET
//Inserts Names into the Trie data structure
public static Node InsertNode(string name, Node root)
{
    //Is name null?
    if (string.IsNullOrEmpty(name))
        throw new ArgumentNullException("Null Key");

    //set the index, start inserting characters
    int index = 1;
    
    //key
    string key;

    //start with the root node
    Node currentNode = root;

    //loop for all charecters in the name
    while (index < = name.Length)
    {
        //get the key character
        key = name[index - 1].ToString(); 

        //does the node with same key already exist?
        Node resultNode = currentNode.Children.GetNodeByKey(key);

        //No, this is a new key
        if (resultNode == null)
        {
            //Add a node
            Node newNode = new Node(key, name.Substring(0, index));
            
            //If reached the last charaecter, this is a valid full name
            if (index == name.Length)
                newNode.IsTerminal = true;
            
            //add the node to currentNode(i.e. Root node for the first time)
            currentNode.Children.Add(newNode);

            //set as the current node
            currentNode = newNode;
        }
        else
        {
            //node already exist, set as tghe current node
            //and move to the next character in the name
            currentNode = resultNode;
        }

        //move to the next character in the name
        index++;
    }

    //all done, return root node
    return root;
}

//FIND
//Find a node given the key("Jo")
public static bool Find(Node node, string key)
{
    //Is key empty
    if (string.IsNullOrEmpty(key))
        return true;//terminal Node

    //get the first character
    string first = key.Substring(0, 1);

    //get the tail: key - first character
    string tail = key.Substring(1);

    Node curNode = node.Children.GetNodeByKey(first);

    //loop until you locate the key i.e. "Jo"
    if (curNode != null)
    {
        return Find(curNode, tail);
    }
    else
    {
        //not found, return false
        return false;
    }
}
CODE_END#

H3#72. Volatile vs Atomic
Volatile and Atomic are two different concepts. Volatile ensures, that a certain, expected (memory) state is true across 
different threads, while Atomics ensure that operation on variables are performed atomically.

- If the variable is not volatile and atomic. and if two threads reads at same time then they will take same value in 
entire thread. if one thread changes it
then second thread will not aware about it.
- but for volatile if one thread changes it, second thread will immediately will get refreshed value.
- but Volatile only ensures that the access is atomically, while Atomics ensure that the operation is atomically.
Take the following example:

i = i + 1;
No matter how you define i, a different Thread reading the value just when the above line is executed might get i, 
or i + 1, because the operation is not atomically. If the other thread sets i to a different value, in worst case 
i could be set back to whatever it was before by thread A, because it was just in the middle of calculating i + 1 based 
on the old value, and then set i again to that old value + 1. Explanation:

- volatile = visibility is useful when you just have to do assignment of attribute. so, other thread can refreshed value. 
But if you want to modify value by non-atomic operation (ie: sum)
then you need atomic.

- So to perform atomic operation: atomic comes into picture.
But AtomicInteger, AtomicReference are based on the Compare and swap instruction. CAS has three operands a memory location
V on which to operate, the expected old value A, and the new value B. CAS atomically updates V to the new value B, but only
if the value in V matches the expected old value A; otherwise it does nothing. In either case, it returns the value currently in V.
This is used by JVM in AtomicInteger, AtomicReference and they call the function as compareAndSet() if this functionality is not 
supported by underlying processor then JVM implements it by spin lock.
