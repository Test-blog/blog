H3#@1.	You are given 2 documents. We want to know how similar they are through N-Grams. e:Given an input n (n = number of word in the Ngram) and two documents(strings) find the intersection of the NGrams of two document. E.g doc1 = 'This is a dog' doc2 = 'This is a cat' n = 3 Ngrams for doc1 = 'This is a', 'is a dog' Ngrams for doc2 = 'This is a', 'is a cat' Output 'This is a' Find a efficient way and give its complexity.a#@http://stackoverflow.com/questions/1032288/n-grams-explanation-2-applications?rq=1#@Explaination: CODE_START#START_SNIPPETpublic class Interview {	private void process(String file, HashMap<String, Boolean> cmap, int n){		String[] words = file.split(“ “);		if (words.length < n)			return;		for (int i = 0; i<words.length-n; i++){			StringBuilder sb = new StringBuilder();			for (int j = i; j<n+i; j++)				sb.append(words[j] + “ “);			String key = sb.toString();			if (cmap.containsKey(key))				cmap.put(key, Boolean.True);			else				cmap.put(key, Boolean.False);					}	}	public List<String> intersectionNGram(String file1, String file2, int n){		List<String> result = new ArrayList();		HashMap<String, Boolean> cmap = new HashMap();		process(file1, cmap, n);		if (cmap.size()==0)			return result;		process(file2, cmap, n);		for (String key : cmap.keySet()){			if (cmap.get(key))				result.add(key);		}		return result;	}}CODE_END#H3#@2. You are given an array representing integer. Write a function which increments this integer. Example: input [1,2,3] (represents 123) -> output [1,2,4]CODE_START#START_SNIPPETprivate ArrayList<Integer> increment(ArrayList<Integer> number) {	int carry = 1;	for(int i=number.size()-1;i>=0 && carry!=0;i--) {  //Make sure to stop this loop once carry =0		carry = number.get(i) + carry;		number.set(i, carry%10);		carry = carry/10;	}	if(carry>;0) {		number.add(0, carry);	}	return number;}CODE_END#H3#@3. Given an unbalanced binary tree, write code to select a node at random (each node has an equal probability of being selected).CODE_START#START_SNIPPETYou can do it with a single pass of the tree. The algorithm is the same as with a list.When you see the first item in the tree, you set it as the selected item.When you see the second item, you pick a random number in the range (0,2]. If it's 1, then the new item becomes the selected item. Otherwise you skip that item.For each node you see, you increase the count, and with probability 1/count, you select it. So at the 101st node, you pick a random number in the range (0,101]. If it's 100, that node is the new selected node.When you're done traversing the tree, return the selected node. The operation is O(n) in time, with n being the number of nodes in the tree, and O(1) in space. No preprocessing required.Explaination;For example with 2 nodes you select the first item. Then when you see the second item you replace the first item with probability 1/2. When you see the third item, you replace the selected item with probability 1/3. Every item has equal probability of being the selected item.-> you have 5 nodes:(1) check 2nd node: (0,1)=>1 => current=2(2) check 3 node: (0,2)=>1 => current=2(3) check 4 node: (0,3)=>3 => current=4(4) check 5 node: (0,4)=>2 => current=4Answer: 4CODE_END#H3#@4. what is the use of XOR in math problem.H3#@5. ComparatorCODE_START#START_SNIPPETTreeSet<TimeWindow> set = new TreeSet<TimeWindow>(new TimeWindowComparator());public static class TimeWindowComparator implements Comparator<TimeWindow>{	    @Override	    public int compare(TimeWindow t1, TimeWindow t2) {	        return t1.getStartTime().after(t2) ? -1 : 1;	    }}CODE_END#H3#@6. TreeSet vs HashSetHashSet is much faster than TreeSet (constant-time versus log-time for most operations like add, remove and contains) but offers no ordering guarantees like TreeSet.HashSetclass offers constant time performance for the basic operations (add, remove, contains and size).it does not guarantee that the order of elements will remain constant over timeiteration performance depends on the initial capacity and the load factor of the HashSet.It's quite safe to accept default load factor but you may want to specify an initial capacity that's about twice the size to which you expect the set to grow.TreeSetguarantees log(n) time cost for the basic operations (add, remove and contains)guarantees that elements of set will be sorted (ascending, natural, or the one specified by you via its constructor) (implements SortedSet)doesn't offer any tuning parameters for iteration performanceoffers a few handy methods to deal with the ordered set like first(), last(), headSet(), and tailSet() etcImportant points:Both guarantee duplicate-free collection of elementsIt is generally faster to add elements to the HashSet and then convert the collection to a TreeSet for a duplicate-free sorted traversal.None of these implementation are synchronized. That is if multiple threads access a set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.LinkedHashSet is in some sense intermediate between HashSet and TreeSet. Implemented as a hash table with a linked list running through it, however it provides insertion-ordered iteration which is not same as sorted traversal guaranteed by TreeSet.So choice of usage depends entirely on your needs but I feel that even if you need an ordered collection then you should still prefer HashSet to create the Set and then convert it into TreeSet.e.g. SortedSet<String> s = new TreeSet<String>(hashSet);H3#@7. You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e.g., M becomes a substring of N located at i and starting at j).EXAMPLE:Input: N = 10000000000, M = 10101, i = 2, j = 6Output: N = 10001010100CODE_START#START_SNIPPET public static int updateBits(int n, int m, int i, int j) { int max = ~0; /* All 1’s */ // 1’s through position j, then 0’s : If you subtract 100000 - 1 = 011110 (first and last bit=0 and rest of them 1's) int left = max - ((1 << j) - 1); // 1’s after position i int right = ((1 << i) - 1); // 1’s, with 0s between i and j int mask = left | right; // Clear i through j, then put m in there return (n & mask) | (m << i);}CODE_END#H3#@8. How to find if number if power of 2.Ans: if (n & (n-1)) = 0What does it mean if A & B == 0?It means that A and B never have a 1 bit in the same place. So if n & (n-1) == 0, then n andn-1 never share a 1.What does n-1 look like (as compared with n)?Try doing subtraction by hand (in base 2 or 10). What happens? 1101011000 [base 2]- 1= 1101010111 [base 2] 593100 [base 10]- 1= 593099 [base 10]When you subtract 1 from a number, you look at the least significant bit. If it’s a 1 you changeit to zero and you are done. If it’s a zero, you must “borrow” from a larger bit. So, you go toincreasingly larger bits, changing each bit from a 0 to a 1, until you find a 1. You flip that oneto a 0 and you are done.Thus, n-1 will look like n, except that n’s initial 0s will be 1’s in n-1, and n’s least significant 1will be a 0 in (n-1). That is:if n = abcde1000then n-1 = abcde0111So what does n & (n-1) == 0 indicate?n and (n-1) must have no 1s in common. Given that they look like this:if n = abcde1000then n-1 = abcde0111abcde must be all 0s, which means that n must look like this: 00001000. n is therefore apower of two.So, we have our answer: ((n & (n-1)) == 0) checks if n is a power of 2 (or 0)H3#@9. Write a function to determine the number of bits required to convert integer A to integer B.Input: 31, 14 :    11111 , 01110Output: 2Ans: if you XOR : 1^0 = 1C= A^Bwhile(C>0){count+=c>>1;}H3#@10. Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, etc).Mask all odd bits with 10101010 in binary (which is 0xAA), then shift them left to put them inthe even bits. Then, perform a similar operation for even bits. This takes a total 5 instructions.1 public static int swapOddEvenBits(int x) {2 return ( ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1) );3 } H3#@11. Place for good Distributed design question answer:H3#@12. Why and what is Consistent Distributed hashing.a#@http://n00tc0d3r.blogspot.com/2013/09/big-data-consistent-hashing.html#@Click here.H3#@13. Tiny Urla#@http://n00tc0d3r.blogspot.com/#@Click here.Short url = 6 letters. [0-9a-zA-Z] => [26+26+9=62 => 62^6 = 56.8 billion-> Create distributed hashmap/ Sharded database to generate unique number:ie:e.g. 0-0, ..., 9-9, 10-a, 11-b, ..., 35-z, 36-A, ..., 61-Z.CODE_START#START_SNIPPETpublic String shorturl(int id, int base, HashMap map) {  StringBuilder res = new StringBuilder();  while (id > 0) {    int digit = id % base;    res.append(map.get(digit));    id /= base;  }  while (res.length() < 6)  res.append('0');  return res.reverse().toString();}CODE_END#H3#@14. Clone graphCODE_START#START_SNIPPETprivate UndirectedGraphNode cloneDFS(UndirectedGraphNode root, HashMap<UndirectedGraphNode, UndirectedGraphNode> visited) {       if (root == null) return root;       UndirectedGraphNode node = new UndirectedGraphNode(root.label);       visited.put(root, node);          // DFS       for (UndirectedGraphNode nb : root.neighbors) {         if (visited.containsKey(nb)) {           node.neighbors.add(visited.get(nb));         } else {           node.neighbors.add(cloneDFS(nb, visited));         }       }          return node;     }     public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {       return cloneDFS(node, new HashMap<UndirectedGraphNode, UndirectedGraphNode>());     }  CODE_END#H3#@15. Inorder Binary Tree Traversal with Constant SpaceIt first modify the tree to a partial Threaded Binary Tree where all right child pointers that were null in the original tree are pointed to their inorder successor.With that information in hand, it is much easier to conduct an inorder traversal: Go to the left most node, and follow right pointers to complete the traversal.During the traversal, Morris algorithm then fix the modified right pointers and set them back to null.An inorder traversal can be implemented using recursion or stack (see previous post). But both methods requires O(h) space, where h is the height of the tree. That said, the worst case space complexity can be O(n).CODE_START#START_SNIPPET			16		12	11      14	      13   1511->12->13->14->15->16 (It means you (16) will come after your child's(12) right most leaf node(15))		  //(1) It means 15.right = 16//(2) Go to your left node(12) and then right most leaf node(15) and then link it's right to you(16)pre = cur.leftpre=pre->.....right till right==nullpre.right=cur//(3) then move to left node : 12 and again do the same as (1)//(4) if pre.right!=null it means it's loop : we need to break it so, cur = cur.right (here you will move to your immediate right node for further traversing)pre.right = nullprivate void inorderMorris(TreeNode root, ArrayList<Integer> values) {     TreeNode cur = root;        while (cur != null) {       if (cur.left != null) {         TreeNode pre = cur.left;         while (pre.right != null && pre.right != cur) {           pre = pre.right;  //Move to child's Right most and move it's link to this.curr node       }         if (pre.right == null) { // set right to successor           pre.right = cur;           cur = cur.left;         } else { // visit and revert the change           pre.right = null;           values.add(cur.val);           cur = cur.right;      //This is important: that's where we move to Right Child of any node       }       } else { // visit and move to successor        values.add(cur.val);         cur = cur.right;       }     }   }  CODE_END#H3#@16. Design LRU cache.This algorithm touches each node at most three times: find successor, visit, fix right pointer of pre node. So, it runs in time O(n) and uses O(1) space!We need a data structure to check whether a page number is in cache in constant time. HashMap with each page number as a key can make it.We also need a data structure to maintain page numbers in cache in the order of their access time. One way to do that is to keep a timestamp field for each record, but we still need to sort them which cannot be done in O(1) time. Alternatively, we can use a linked list to keep all records, and move the newly visited one to the head of the list. To get O(1) time complexity for updating such a linked list, we need a doubly linked list.Each time when a new page number comes in,- If it is already in the cache, move the node to the head of the linked list;- If it is not in the cache, insert it to the head of the linked list and update the current capacity of the cache. If the cache is full, remove the last node of the linked list. (So, we also need a tail pointer. :)CODE_START#START_SNIPPETpublic class PostOrderBinaryTreeIteratorImpl implements PostOrderBinaryTreeIterator {     Stack<TreeNode> stack = new Stack<TreeNode>();        /** find the first leaf in a tree rooted at cur and store intermediate nodes */     private void findNextLeaf(TreeNode cur) {       while (cur != null) {         stack.push(cur);         if (cur.left != null) {           cur = cur.left;         } else {           cur = cur.right;         }       }     }        /** Constructor */     public PostOrderBinaryTreeIterator(TreeNode root) {       findNextLeaf(root);     }        /** {@inheritDoc} */     @Override     public boolean hasNext() {       return !stack.isEmpty();     }        /** {@inheritDoc} */     @Override     public Integer next() {       if (!hasNext()) {         throw new NoSuchElementException("All nodes have been visited!");       }          TreeNode res = stack.pop();       if (!stack.isEmpty()) {         TreeNode top = stack.peek();         if (res == top.left) {           findNextLeaf(top.right); // find next leaf in right sub-tree        }       }          return res.val;     }        @Override     public void remove() {       throw new UnsupportedOperationException("remove() is not supported.");     }   }  CODE_END#H3#@17. Maximal Surpasser Count Problem (Binary Search Tree Solution)ou have an array of integers and for every element of the array you count the number of elements to the right that are strictly greater than that element. For example, the array may be:82    74    17    93    96    20    25    55    15    24    25    56and the resultant surpasser count array is:2    2    8    1    0    5    2    1    3    2    1    0and the maximal surpasser count is 8. Note, the problem asks to find 8, not to construct the array in full but we’ll do that anyway.The idea is simple. Every node in the tree is to have three fields – the key, i.e. number in the array that the node corresponds to, number of nodes inserted to the right (A) and the maximal surpasser count so far (B). There is one node for every distinct element of the array. We start reading the array from the right to the left. The first node gets a key of 56 and both fields are set to 0. Next number is 25, which gets inserted as a left child of 56. Because we made a move to the left, the new node will have to add 1 to its count of surpassers. Next one is 24, and, since it requires two moves to the left, it gets to have 2 as its count of surpassers Skipping 15, when we get to 55, we make one move to the left but then to the right. So node 55 will have surpasser count as 1 (correct) but what about node 25? Remember, 55 gets to be inserted to the right of 25. Node 25 will have its B incremented, and next node inserted after 25 will have to pickup the B.CODE_START#START_SNIPPET#include <iostream>#include <vector>#include <algorithm>using namespace std; class Node;vector vc;class Node {  public:    Node * left;    Node * right;     int k;     // key    int c;    // count of duplicate nodes    int surpasserCount, largerThanCount;     Node(){          right = left = NULL;      surpasserCount = largerThanCount = k = c= 0 ;    }};void insert(const int k, Node * r, int m){  if (k == r->k){    r->surpasserCount = r->largerThanCount + m ;         r->c++;    vc.push_back(r->surpasserCount);  } else if (k k) {    if (r->left){      insert (k, r->left, m+1 + r->largerThanCount+r->c);    } else {      r->left = new Node;       r->left->k = k;             r->left->surpasserCount =  m+1 + r->largerThanCount + r->c;      vc.push_back(r->left->surpasserCount);    }  } else {    r->largerThanCount ++;     if (r->right){      insert (k , r->right, m);     } else {      r->right = new Node;       r->right->k = k;             r->right->surpasserCount = m + r->c;      vc.push_back(r->right->surpasserCount);    }    }}int main(int argc, char ** argv) {  int k[] = {82, 74, 17, 93, 96, 20, 25, 55, 15, 24, 25, 56};  int l = 12;   Node * r = new Node;  r->k = k[l-1];   vc.push_back(0);  for (int i = l-2; i >= 0; i--){    insert (k[i], r, 0);  }   for (int i = vc.size()-1; i>=0;i--){    cout << vc[i] << " ";  }  cout << endl;  cout << "Maximal surpasser count is: " << * max_element(vc.begin(), vc.end()) << endl;  return(0); }CODE_END#H3#@18. 