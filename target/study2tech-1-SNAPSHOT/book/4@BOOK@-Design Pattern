H2#@What is Design Pattern?H3#@ Strategy Design PatternThe Strategy pattern is known as a behavioural pattern - it's used to manage algorithms, relationships and responsibilities between objects. The definition of Strategy provided in the original Gang of Four book on Design Patterns states: H4#@How Does It Work In Java?Let's use the example of a file compression tool - where we create either zip or rar files. First we'll need a strategy: CODE_START#START_SNIPPET//Strategy Interfacepublic interface CompressionStrategy{   public void compressFiles(ArrayList<File> files);}CODE_END#And we'll need to provide our two implementations, one for zip and one for rarCODE_START#START_SNIPPETpublic class ZipCompressionStrategy implements CompressionStrategy{     public void compressFiles(ArrayList<File> files)   {     //using ZIP approach   }}CODE_END#CODE_START#START_SNIPPETpublic class RarCompressionStrategy implements CompressionStrategy{     public void compressFiles(ArrayList<File> files)   {     //using RAR approach   }}CODE_END#Our context will provide a way for the client to compress the files. Let's say that there is a preferences setting in our application that sets which compression algorithm to use. We can change our strategy using the setCompressionStrategy method in the Context.CODE_START#START_SNIPPETpublic class CompressionContext{   private CompressionStrategy strategy;      //this can be set at runtime by the application preferences   public void setCompressionStrategy(CompressionStrategy strategy)    {       this.strategy = strategy;     }  //use the strategy   public void createArchive(ArrayList<File> files)    {        strategy.compressFiles(files);   }}CODE_END#It's obvious that all the client has to do now is pass through the files to the CompressionContextCODE_START#START_SNIPPETpublic class Client{   public static void main(String[] args)   {      CompressionContext ctx = new CompressionContext();      //we could assume context is already set by preferences       ctx.setCompressionStrategy(new ZipCompressionStrategy());          //get a list of files     ...     ctx.createArchive(fileList);        }} CODE_END#H3#@The Observer PatternBefore we get into the theory and code behind the Observer, let's take a look at a real world example, such as RSS feeds.  When I want to get updates from a particular feed, I add it to my feed reader. Any time that the RSS feed has an update, it will appear in my reader automatically.  This is the Observer pattern in action, a publisher/subscriber relationship with one source having many subscribers. The Observer is known as a behavioural pattern, as it's used to form relationships between objects at runtime.  The definition provided in the original Gang of Four book on Design Patterns states:H4#@Where Would I Use This Pattern?In general, you want to use this pattern to reduce coupling. If you have an object that needs to share it's state with others, without knowing who those objects are, the Observer is exactly what you need.You'll have seen, and probably used, the Observer many times if you've done any UI programming, especially in Swing. The whole concept of listeners is based on this pattern. The event listener is the most popular, where you register an ActionListener to a UI control, such a button, and react to action events using the actionPerformed method. In this case, the ActionListener is the Observer and the button is your Subject. As the button changes state, you can react, if you choose to, in your actionPerformed method. The typical real world uses of the pattern all revolve around this type of event handling system. b#@img#@http://java.dzone.com/sites/all/files/observer_pattern_java_0.PNGb#@The slight difference from the classic definition is that Observable is used in place of the Subject and is implemented as a class, while the Observer interface remains the same. Let's take a look at an implementation of the pattern with a real example. In our example, the subject will be a DataStore, with a Screen class as the observer.First, let's make our DataStore class observable by extending the java.util.Observable class. This means that our DataStore has all the methods and functionality available to make it a Subject, according to our pattern. CODE_START#START_SNIPPETimport java.util.Observable;public class DataStore extends Observable{		private String data;		public String getData()	{		return data;	}		public void setData(String data)	{		this.data =data;		//mark the observable as changed		setChanged();	}	}CODE_END#You'll notice that we have called the setChanged() method of the Observable. This is necessary in order for the call to notify observers to send out the update. Without this set, the Observable will see no reason to send out the update. Next, let's create our Observer. To do this, all we need to do is implement the Observer interface which forces us to write an update method, to deal with changes in the Observable's state. CODE_START#START_SNIPPETpublic class Screen implements Observer {	@Override	public void update(Observable o, Object arg) {		//act on the update	}}CODE_END#Adding our Screen as an observer to the DataStore is simple: CODE_START#START_SNIPPETScreen screen = new Screen();DataStore dataStore = new DataStore();//register observer dataStore.addObserver(screen);CODE_END#When the data changes, we want to notify all observers of this object. To do this, we just need to call the notifyObservers method when we want an update sent out CODE_START#START_SNIPPET//send a notificationdataStore.notifyObservers();CODE_END#CODE_START#START_SNIPPETCODE_END#CODE_START#START_SNIPPETCODE_END#CODE_START#START_SNIPPETCODE_END#CODE_START#START_SNIPPETCODE_END#CODE_START#START_SNIPPETCODE_END#CODE_START#START_SNIPPETCODE_END#