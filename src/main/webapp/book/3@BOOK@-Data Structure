H3#@1.	How to check tree if binary tree is balanced tree:CODE_START#START_SNIPPETgetHeight(Node node){	if(node==null){return 0;}	return Math.max(getHeight(node.left),getHeight(node.right))+1;}boolean isBalanced(Node node){	int height = getHeight(node.left) - getHeight(node.right);	if(height>1){return false;}	else{	isBalanced(node.left) && isBalanced(node.right);}CODE_END#H3#@2.	Reverse doubly linked list.CODE_START#START_SNIPPET/* Function to reverse a Doubly Linked List */void reverse(struct node **head_ref){     struct node *temp = NULL;       struct node *current = *head_ref;           /* swap next and prev for all nodes of        doubly linked list */     while (current !=  NULL)     {       temp = current->prev;       current->prev = current->next;       current->next = temp;                     current = current->prev;     }          }     CODE_END#H3#@3. BFS TraversalH4#@BFS using QueueCODE_START#START_SNIPPETprintLevelorder(tree)1) Create an empty queue q2) temp_node = root /*start from root*/3) Loop while temp_node is not NULL    a) print temp_node->data.    b) Enqueue temp_node’s children (first left then right children) to q    c) Dequeue a node from q and assign it’s value to temp_nodeCODE_END#H4#@BFS without using Queue: RecursiveCODE_START#START_SNIPPET/*Function to print level order traversal of tree*/printLevelorder(tree)for d = 1 to height(tree)   printGivenLevel(tree, d);/*Function to print all nodes at a given level*/printGivenLevel(tree, level)if tree is NULL then return;if level is 1, then    print(tree->data);else if level greater than 1, then    printGivenLevel(tree->left, level-1);    printGivenLevel(tree->right, level-1);CODE_END#H3#@4. Check if binary tree is BST.1. In order Traversal2. Make sure :  INTEGER_MIN < left node child < current.node  (isthisBSTUtil(root->left, min, root->data))3. And make sureL current.node < right  node child < INTEGER.MAX (isthis BSTUtil(root->right,root->data, max)CODE_START#START_SNIPPETbool isthisBST(nodeptr root){	return isthisBSTUtil(root,INT_MIN, INT_MAX);}int isthisBSTUtil(nodeptr root, int min, int max){	if(root == NULL) return true; //empty tree is a bst	if(root-data < min || root->data >max) return false;	return (isthisBSTUtil(root->left, min, root->data) || isthis BSTUtil(root->right,root->data, max);}CODE_END#H3#@Perform binary searchCODE_START#START_SNIPPETpublic static int binarySearch( Comparable [ ] a, Comparable x )    {        int low = 0;        int high = a.length - 1;        int mid;        while( low <= high )        {            mid = ( low + high ) / 2;            if( a[ mid ].compareTo( x ) < 0 )                low = mid + 1;            else if( a[ mid ].compareTo( x ) > 0 )                high = mid - 1;            else                return mid;        }        return NOT_FOUND;     // NOT_FOUND = -1	}CODE_END#H3#@5. Find or determine non existence of a number in a sorted list of N numbers where the numbers range over M, M >> N and N large enough to span multiple disks. Algorithm to beat O(log n) bonus points for constant time algorithm.This problem can be solved using bitmaps.bitmap will be an array (say b_array) where we have one bit per M possible number. If we use a character array to store bitmaps, b_array size will be M/8, since 1 char can store 8 bits. Bitmap array will be initialized to zero first. Now for each of the N numbers its corresponding bit should be turned on(1). Corresponding bit for 'n' can be found as follows:CODE_START#START_SNIPPETbase = n/8; (base is the char whose certain bit needs to be set)offset = 1 << (n mod 8); (offset is the bit to be set)b_array[base] |= offset; (I set the particular bit)Once this is done of all N numbers, given a number m,we can first find corresponding  bit offset and check whether it is one.base = m/8; (base is the char whose certain bit needs to be set)offset = 1 << (m mod 8); (offset is the bit to be set)if (b_array[base] & offset)    // found the numberelse    //number could not be foundCODE_END#H3#@6. Find height of Binary tree without recursion CODE_START#START_SNIPPETint maxDepthIterative(BinaryTree *root) {  if (!root) return 0;  stack<BinaryTree*> s;  s.push(root);  int maxDepth = 0;  BinaryTree *prev = NULL;  while (!s.empty()) {    BinaryTree *curr = s.top();    if (!prev || prev->left == curr || prev->right == curr) {      if (curr->left)        s.push(curr->left);      else if (curr->right)        s.push(curr->right);    } else if (curr->left == prev) {      if (curr->right)        s.push(curr->right);    } else {      s.pop();    }    prev = curr;    if (s.size() > maxDepth)      maxDepth = s.size();  }  return maxDepth;}CODE_END#H3#@7. Convert Binary Search to Doubly linked listCODE_START#START_SNIPPET			1		2		3	4	   5[1] Do in order traversaltraversal(node.left)Logictraversal(node.right)[2] Logic(a) need to link left of list as Previous node of our in-order traversal, i.e.: for 2 left = previous 4(b) and for 4 left = null so, 4 should be head.4-2-5-1-3 void convertBSTToDLL(treenode* curNode, treenode*& prevNode, treenode*& listHead){    if (curNode)    {		//[1] Traversal left        convertBSTToDLL(curNode->left, prevNode, listHead);				//[2] Logic        if (prevNode)        {            curNode->left = prevNode;            prevNode->right = curNode;        }        else        {            listHead = curNode;        }        prevNode = curNode;				//[3] Traversal right        convertBSTToDLL(curNode->right, prevNode, listHead);    }    return;}CODE_END#H3#@8.	Convert  decimal to binaryCODE_START#START_SNIPPETimport java.util.*;public class number{	public static void main (String [] args)	{		Scanner input = new Scanner (System.in);		System.out.println ("Input decimal number");		int decimal = input.nextInt ();		input.close ();				int base = 2;		int result = 0;		int multiplier = 1;				while (decimal>0)		{			int residue = decimal%base;			decimal = decimal/base;			result = result +residue*multiplier;			multiplier = multiplier * 10;		}		System.out.println ("binary....."+result);	}}CODE_END#H3#@9.	COnvert decimal to HexCODE_START#START_SNIPPETfunction toHex(d) {  var r = d % 16;  var result;  if (d-r == 0)     result = toChar(r);  else     result = toHex( (d-r)/16 ) + toChar(r);  return result;} function toChar(n) {  const alpha = "0123456789ABCDEF";  return alpha.charAt(n);}CODE_END#H3#@10.	Write DFS using stack.CODE_START#START_SNIPPETpublic void dfs(){	//DFS uses Stack data structure	Stack s=new Stack();	s.push(this.rootNode);	rootNode.visited=true;	printNode(rootNode);	while(!s.isEmpty())	{		Node n=(Node)s.peek();		Node child=getUnvisitedChildNode(n);		if(child!=null)		{			child.visited=true;			printNode(child);			s.push(child);		}		else		{			s.pop();		}	}	//Clear visited property of nodes	clearNodes();}CODE_END#H3#@11.	Write BFS using queueCODE_START#START_SNIPPETpublic void bfs(){	//BFS uses Queue data structure	Queue q=new LinkedList();	q.add(this.rootNode);	printNode(this.rootNode);	rootNode.visited=true;	while(!q.isEmpty())	{		Node n=(Node)q.remove();		Node child=null;		while((child=getUnvisitedChildNode(n))!=null)		{			child.visited=true;			printNode(child);			q.add(child);		}	}	//Clear visited property of nodes	clearNodes();}CODE_END#H3#@12. Given a sorted array of integers, how can you find the location of a particular integer x?Use binary search. Compare the number in the middle of the arraywith x. If it is equal, we are done. If the number is greater, we know to look in thesecond half of the array. If it is smaller, we know to look in the first half. We canrepeat the search on the appropriate half of the array by comparing the middleelement of that array with x, once again narrowing our search by a factor of 2. Werepeat this process until we find x. This algorithm takes O(log n) time.H3#@13.	What is Mutexes and semaphores:bo#@Mutex:A mutex is like a lock. Mutexes are used in parallel programming to ensure that onlyone thread can access a shared resource at a time. For example, say one thread ismodifying an array. When it has gotten halfway through the array, the processorswitches to another thread. If we were not using mutexes, the thread might try tomodify the array as well, which is probably not what we want.b#@To prevent this, we could use a mutex. Conceptually, a mutex is an integer thatstarts at 1. Whenever a thread needs to alter the array, it "locks" the mutex. Thiscauses the thread to wait until the number is positive and then decreases it by one.When the thread is done modifying the array, it "unlocks" the mutex, causing thenumber to increase by 1. If we are sure to lock the mutex before modifying thearray and to unlock it when we are done, then we know that no two threads willmodify the array at the same time.b#@bo#@SemaphoresSemaphores are more general than mutexes. They differ only in that a semaphore'sinteger may start at a number greater than 1. The number at which a semaphorestarts is the number of threads that may access the resource at once. Semaphoressupport "wait" and "signal" operations, which are analogous to the "lock" and"unlock" operations of mutexes.H3#@14.	Write a function to convert a string into an integer.Go through the string from beginning to end. If the first character is anegative sign, remember this fact. Keep a running total, which starts at 0. Each timeyou reach a new digit, multiply the total by 10 and add the new digit. When youreach the end, return the current total, or, if there was a negative sign, the inverse ofthe number.H3#@15.	Merge SortMerge sort is a recursive way to sort an array. First, you divide the array in half andrecursively sort each half of the array. Then, you combine the two halves into asorted array. So a merge sort function would look something like this:img#@http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gifCODE_START#START_SNIPPETvoid mergeSort(int numbers[], int temp[], int array_size){        m_sort(numbers, temp, 0, array_size - 1);}void m_sort(int numbers[], int temp[], int left, int right){       int mid;        if (right > left)        {            mid = (right + left) / 2;            m_sort(numbers, temp, left, mid);            m_sort(numbers, temp, mid+1, right);            merge(numbers, temp, left, mid+1, right);        }}void merge(int numbers[], int temp[], int left, int mid, int right)        {           int i, left_end, num_elements, tmp_pos;           left_end = mid - 1;            tmp_pos = left;            num_elements = right - left + 1;while ((left <= left_end) && (mid <= right))        {                if (numbers[left] <= numbers[mid])                {                        temp[tmp_pos] = numbers[left];                        tmp_pos = tmp_pos + 1;                        left = left +1;                }                else                {                        temp[tmp_pos] = numbers[mid];                        tmp_pos = tmp_pos + 1;                        mid = mid + 1;                }        }        while (left <= left_end)                {                        temp[tmp_pos] = numbers[left];                        left = left + 1;                        tmp_pos = tmp_pos + 1;                }                while (mid <= right)                {                        temp[tmp_pos] = numbers[mid];                        mid = mid + 1;                        tmp_pos = tmp_pos + 1;                }                for (i = 0; i <= num_elements; i++)                {                        numbers[right] = temp[right];                        right = right - 1;                }        }CODE_END#H3#@16.	Write a program to determine whether an input string x is a substring of another input string y.CODE_START#START_SNIPPETbool hasSubstring(const char *str, const char *find) {	if (str[0] == '\0' && find[0] == '\0')		return true;	for(int i = 0; str[i] != '\0'; i++) {		bool foundNonMatch = false;		for(int j = 0; find[j] != '\0'; j++) {			if (str[i + j] != find[j]) {			foundNonMatch = true;			break;			}		}	if (!foundNonMatch)	return true;	}	return false;}CODE_END#H3#@17.	Write program : non-recursive in-order traversalCODE_START#START_SNIPPETvoid inorder( node *root){	node *p;	p=root;	top=0;	do	{		while(p!=NULL)		{			stk[top]=p->data;			top++;			p=p->left;		}		if(top>0)		{			p=pop(root);			cout << p->data;			p=p->right;		}	}while(top!=0 || p!=NULL);}CODE_END#H3#@18.	Find 5th largest element from BST.CODE_START#START_SNIPPETint num=0;void max(tree*t){        if(t==NULL)                return;        max(t->right);        num++;        if(num==5)                printf("%d\n",t->no);        max(t->left);}CODE_END#H3#@19.	FInd lowest common ancestor for two nodes in binary tree.CODE_START#START_SNIPPETtreeNodePtr findLCA(treeNodePtr root, treeNodePtr p, treeNodePtr q) {        // no root no LCA.        if(!root) {                return NULL;        }        // if either p or q is the root then root is LCA.        if(root==p || root==q) {                return root;        } else {                // get LCA of p and q in left subtree.                treeNodePtr l=findLCA(root->left , p , q);                // get LCA of p and q in right subtree.                treeNodePtr r=findLCA(root->right , p, q);                // if one of p or q is in leftsubtree and other is in right                // then root it the LCA.                if(l && r) {                        return root;                }                // else if l is not null, l is LCA.                else if(l) {                        return l;                } else {                        return r;                }        }}CODE_END#H3#@20.	Print possible closed parenthesis pairs program.i.e.: Pair = 3Combinations should be:((())))(()())(())()()(())()()()CODE_START#START_SNIPPETpublic class App {	 static int total = 3;	    static private void Brackets(String output, int open, int close, int pairs) {	        if ((open == pairs) && (close == pairs) && output.length() == total * 2) {	            System.out.println(output);	        } else {	            if (open < pairs)	                Brackets(output + "(", open + 1, close, pairs);	            if (close < open)	                Brackets(output + ")", open, close + 1, pairs);	        }	    }	    public static void main(String[] args) {	        Brackets("", 0, 0, 3);	    }}CODE_END#H3#@21. Permutation for a given characters.CODE_START#START_SNIPPETpublic class Permute {	void permute( String str ){	    int          length = str.length();	    boolean[]    used = new boolean[ length ];	    StringBuffer out = new StringBuffer();	    char[]       in = str.toCharArray();	    doPermute( in, out, used, length, 0 );	}	void doPermute( char[] in, StringBuffer out,	                boolean[] used, int length, int level ){	    if( level == length ){	        System.out.println( out.toString() );	        return;	    }	    for( int i = 0; i < length; ++i ){	        if( used[i] ) continue;	        out.append( in[i] );	        used[i] = true;	        doPermute( in, out, used, length, level + 1 );	        used[i] = false;	        out.setLength( out.length() - 1 );	    }	}	}CODE_END#H3#@22. Design a class library for writing card games.CODE_START#START_SNIPPETpublic class Card{    private short rank, suit;    private static String[] suits = { "hearts", "spades", "diamonds", "clubs" };    private static String[] ranks  = { "Ace", "2", "3", "4", "5", "6", "7",                    "8", "9", "10", "Jack", "Queen", "King" };    public static String rankAsString( int __rank ) {        return ranks[__rank];    }public short getRank() {         return rank;    }    public short getSuit() {        return suit;    }}(win)		isPair,isRed,handTotalgame- player - pile---|			|Deck-Icard------  Card(shuffle,		(getSuit,getRank)isFlush,handTotal)CODE_END#H3#@23. Define types of cookies.bo#@Session cookie:A session cookie only lasts for the duration of users using the website. A session cookie will expire if a user closes his/her browser, or if a user hasn't visited the server for certain period of time (called session idle timeout), and the server would expire/invalidate the user session.b#@bo#@Persistent cookie:A persistent cookie will outlast user sessions. If a persistent cookie has Max-Age set to 1 year, then, within the year, the initial value set in that cookie would be sent back to server every time the user is visiting the server. This could be used to record a vital piece of information such as how the user initially came to this website. For this reason, persistent cookie is also called tracking cookieb#@bo#@Secure cookie:A secure cookie is only used when a browser is visiting a server via HTTPS, that will make sure that cookie is always encrypted when transmitting from client to server, and therefore less likely to be exposed to cookie theft via eavesdropping.b#@bo#@HttpOnly cookie:HttpOnly cookie is still in IETF draft[8], though most of the modern browsers support it. On a supported browser, a HttpOnly cookie will only be used when transmitting HTTP (or HTTPS) requests, but the cookie value is not available to client side script, hence mitigate the threat of cookie theft via Cross-site scripting.b#@bo#@Third-party cookie:First-party cookies are cookies set with the same domain or its subdomain in your browser's address bar. Third-party cookies are cookies being set with different domains than the one shown on address bar.For example: Suppose a user visits www.example1.com, it sets a cookie with domain ad.foxytracking.com. When the user later visits www.example2.com, another cookie is placed with domain ad.foxytracking.com, eventually these cookies will be sent to the advertiser when loading their ads or visiting their website, the advertiser can then build up users' browsing history across all the websites this advertiser has footprints on.b#@bo#@Super cookie:A Super cookie is a cookie with a Public Suffix [9] domain, like .com, .co.uk or k12.ca.us.Most browsers, by default, allow first-party cookies, i.e., a cookie with domain to be the same or sub-domain of the requesting host. For example, a user visiting www.example.com can have a cookie set with domain www.example.com or .example.com, but not .com. A super cookie with domain .com would be blocked by browsers; otherwise, attacker.com could set a super cookie with domain .com and potentially disrupt or impersonate legitimate user requests to example.com. Unfortunately, the Public Suffix List keeps changing, and older versions of browsers will not have the most up-to-date list, and will therefore be vulnerable to certain super cookies.b#@bo#@Zombie cookie:A zombie cookie is any cookie that is automatically recreated after a user has deleted it. This is accomplished by a script storing the content of the cookie in some other location, such as the local storage available to Flash content, and then recreating it from the backup when the cookie's absence is detected.H3#@ Given two strings, check if one string is a permutation of the other.b#@ Solution 1: Sort the string and verifyb#@ Solution 2:  Check if the two strings have identical characters count.H3#@24.	ROTATE A MATRIX BY 90 DEGREESb#@[1,  2, 3, 4]                   [9, 6, 9, 1]b#@[9, 8, 5, 6]         –>       	[2, 5, 8, 2]b#@[6, 5, 3, 7]                    [6, 3, 5, 3]b#@[9, 2, 6, 8]                    [8, 7, 6, 4]b#@In our example we have two layers:b#@b#@OUTER LAYER         			 INNER LAYERb#@1 2 3 4b#@9      6                               8 5b#@6      7                               5 3b#@9 2 6 8At each layer we are gonna loop through the elements and swap them as follows:b#@1.- Save the ith element in the top array in a temporary variable (in our example the top array is [1 2 3 4] ).b#@2.- Move the ith element from left to top.b#@3.- Move the ith element from bottom to left.b#@4.- Move the ith element from right to bottom.b#@5.- Save the value of our temporary variable in the ith position in the right array.b#@Tip: Draw 4*4 matrix and run above steps on paper. It will tell you the solution.CODE_START#START_SNIPPETpublic static void rotate(int[][] matrix, int n) { for (int layer = 0; layer < n / 2; ++layer) {	int first = layer;	int last = n - 1 - layer;	for(int i = first; i < last; ++i) {		 int offset = i - first;		 int top = matrix[first][i]; // save top		 // left -> top		 matrix[first][i] = matrix[last-offset][first]; 		 		 // bottom -> left		 matrix[last-offset][first] = matrix[last][last - offset]; 		 		 // right -> bottom		 matrix[last][last - offset] = matrix[i][last]; 		 		 // top -> right		 matrix[i][last] = top; // right <- saved top		 } } }CODE_END#H3#@25.	Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column is set to 0.Track which column and row is having 0. and make all rows and columns 0 for that matrix.CODE_START#START_SNIPPET public static void setZeros(int[][] matrix) {	 int[] row = new int[matrix.length]; 	 int[] column = new int[matrix[0].length]; // Store the row and column index with value 0	for (int i = 0; i < matrix.length; i++) {		for (int j = 0; j < matrix[0].length;j++) {		 if (matrix[i][j] == 0) {		 row[i] = 1; 		 column[j] = 1;		 }	} }  // Set arr[i][j] to 0 if either row i or column j has a 0	 for (int i = 0; i < matrix.length; i++) {		 for (int j = 0; j < matrix[0].length; j++) {			 if ((row[i] == 1 || column[j] == 1)) {			 matrix[i][j] = 0;			 }		}	 } }CODE_END#H3#@26.	Assume you have a method isSubstring which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring (i.e., “waterbottle” is a rotation of “erbottlewat”).CODE_START#START_SNIPPET public static boolean isRotation(String s1, String s2) {	 int len = s1.length();	 /* check that s1 and s2 are equal length and not empty */	 if (len == s2.length() && len > 0) { 		 /* concatenate s1 and s1 within new buffer */		 String s1s1 = s1 + s1;		 return isSubstring(s1s1, s2);	 }	 return false; }CODE_END#H3#@27.	Given a directed graph, design an algorithm to find out whether there is a route between two nodes. This problem can be solved by just simple graph traversal, such as depth first search or breadth first search. Start one of the two nodes and traverse with BFS or DFS.CODE_START#START_SNIPPET	public static boolean search(Graph g, Node start, Node end) { 	LinkedList<Node> q = new LinkedList<Node>(); // operates as Stack 	for (Node u : g.getNodes()) { 	u.state = State.Unvisited; 	} 	start.state = State.Visiting; 	q.add(start); 	Node u; 	while(!q.isEmpty()) { 	u = q.removeFirst(); // i.e., pop() 	if (u != null) { 	for (Node v : u.getAdjacent()) { 		if (v.state == State.Unvisited) {		if (v == end) {		return true;		} else {		v.state = State.Visiting;		q.add(v);		}		}	} 	u.state = State.Visited; 	} } 	return false; CODE_END#H3#@28.	Given a sorted (increasing order) array, write an algorithm to create a binary tree with minimal height.We will try to create a binary tree such that for each node, the number of nodes in the left subtree and the right subtree are equal, if possible.b#@bo#@Algorithm:1.	Insert into the tree the middle element of the array. 2.	Insert (into the left subtree) the left subarray elements 3.	Insert (into the right subtree) the right subarray elements 4.	Recurse CODE_START#START_SNIPPETpublic static TreeNode addToTree(int arr[], int start, int end){ 	if (end < start) { 	return null; 	} 	int mid = (start + end) / 2; 	TreeNode n = new TreeNode(arr[mid]); 	n.left = addToTree(arr, start, mid - 1); 	n.right = addToTree(arr, mid + 1, end); 	return n; } public static TreeNode createMinimalBST(int array[]) { 	return addToTree(array, 0, array.length - 1); } CODE_END#H3#@29.	 Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each depth (eg, if you have a tree with depth D, you’ll have D linked lists).CODE_START#START_SNIPPETArrayList<LinkedList<TreeNode>> findLevelLinkList(TreeNode root) { 	int level = 0; 	ArrayList<LinkedList<TreeNode>> result = new ArrayList<LinkedList<TreeNode>>(); 	LinkedList<TreeNode> list = new LinkedList<TreeNode>(); 	list.add(root); 	result.add(level, list); 	while (true) { 		list = new LinkedList<TreeNode>(); 		for (int i = 0; i < result.get(level).size(); i++) { 			TreeNode n = (TreeNode) result.get(level).get(i); 			if (n != null) { 				if(n.left !=	null)	list.add(n.left);				if(n.right!=	null)	list.add(n.right);			} 		} 			if (list.size() > 0) { 			result.add(level + 1, list); 		} else { 			break; 		} 		level++; 	} 	return result; } CODE_END#b#@We can also implement is with recurssive call.CODE_START#START_SNIPPETList<LinkedList<TreeNode>> createBreathLinkedList(TreeNode root){	List<LinkedList<TreeNode>> list = new ArrayList<LL<TreeNode>>();	createBreathListRecurssive(root,list,0/*root at 0 level*/);}void createBreathListRecurssive(TreeNode root, List<LinkedList<TreeNode>> lists,int level){		if(root==null){return null;}		LinkedList<TreeNode> list = null;	if(lists.size()==level) { /*we add breath linked list into list.so, each sub linked list at each level*/		list = new LinkedList<TreeNode>();		lists.add(list);	}else{		list = lists.get(level);	}	list.add(root);	createBreathListRecurssive(root.left,lists,level+1);	createBreathListRecurssive(root.right,lists,level+1);}CODE_END#H3#@30.	Check if binary tree is binary search tree.CODE_START#START_SNIPPETboolean checkBST(TreeNode n){	return checkBST(n,INT_MIN,INT_MAX);}boolean checkBST(TreeeNode node,int min,int max){		if(node==null){return true;}	int value = node.getValue();		if(value<=min || value>max){return false;}		if(!checkBST(node.left,min,value) || !checkBST(node.right,value,max)){return false;}	return true;	}CODE_END#H3#@31.	Write an algorithm to find the NEXT node (e.g., in-order successor) of a given node in a binary search tree where each node has a link to its parent. We will do in order traversal.b#@1.	If X has a right child, then the successor must be on the right side of X (because of the order in which we visit nodes). Specifically, the left-most child must be the first node visited in that subtree. 2.	Else, we go to X s parent (call it P). 2.a. If X was a left child (P.left = X), then P is the successor of X2.b. If X was a right child (P.right = X), then we have fully visited P, so we call successor(P).b#@CODE_START#START_SNIPPETpublic static TreeNode inorderSucc(TreeNode e) { 	if (e != null) { 	TreeNode p; 	// Found right children -> return 1st inorder node on right 	if (e.parent == null || e.right != null) { 		p = leftMostChild(e.right); 	} else { 	// Go up until we’re on left instead of right (case 2b) 	while ((p = e.parent) != null) { 		if (p.left == e) { /* if node == node.parent.left -> then according to in-order parent is next*/		break;		}		e = p; /* else assign parent to e and traverse further up*/	} 	} 	return p; } return null; } public static TreeNode leftMostChild(TreeNode e) { 	if (e == null) return null; 	while (e.left != null) e = e.left; 	return e; } CODE_END#H3#@32.	Write a function to determine the number of bits required to convert integer A to integer B.1.	XOR A and B. --> It will give you how many bits are different2. Right shift by 1 and increment the count to calculate difference CODE_START#START_SNIPPETpublic static int bitSwapRequired(int a, int b) { int count = 0; for (int c = a ^ b; c != 0; c = c >> 1) { 	count += c & 1; } return count; } CODE_END#H3#@33.	Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, etc). Mask all odd bits with 10101010 in binary (which is 0xAA), then shift them left to put them in the even bits. Then, perform a similar operation for even bits. This takes a total 5 instructions.CODE_START#START_SNIPPETpublic static int swapOddEvenBits(int x) { 	return ( ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1) ); } CODE_END#H3#@34.	Given an input file with four billion integers, provide an algorithm to generate an integer which is not contained in the file. Assume you have 1 GB of memory.It’s possible to find a missing integer with just two passes of the data set. We can divide up the integers into blocks of some size (we’ll discuss how to decide on a size later). Let’s just as-sume that we divide up the integers into blocks of 1000. So, block 0 represents the numbers 0 through 999, block 1 represents blocks 1000 - 1999, etc. Since the range of ints is finite, we know that the number of blocks needed is finite.H3#@35.	You have an array with all the numbers from 1 to N, where N is at most 32,000. The array may have duplicate entries and you do not know what N is. With only 4KB of memory available, how would you print all duplicate elements in the array? We have 4KB of memory which means we can address up to 8 * 4 * (2^10) bits. Note that 32* (2^10) bits is greater than 32000. We can create a bit vector with 32000 bits, where each bit represents one integer.CODE_START#START_SNIPPETboolean get(int pos) { 	int wordNumber = (pos >> 5); // divide by 32 	int bitNumber = (pos & 0x1F); // mod 32 	return (bitset[wordNumber] & (1 << bitNumber)) != 0; } void set(int pos) { 	int wordNumber = (pos >> 5); // divide by 32 	int bitNumber = (pos & 0x1F); // mod 32 	bitset[wordNumber] |= 1 << bitNumber; } CODE_END#H3#@36.	If you were designing a web crawler, how would you avoid getting into infinite loops? Page: www.google.com and www.google.com?query could be same. So, url should not be unique attribute for page.CODE_START#START_SNIPPET1.	Open page and create signature of page based on some specific content2.	Query database if something is similar to it then put that record back to DB with low priority3. 	If not then crawl page and put children to db back.4.	Perform DFS to traverse through DB records.CODE_END#H3#@37.	You are given two sorted arrays, A and B, and A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order. Start from end of A and B. Shift the largest element at the end of buffer of A.CODE_START#START_SNIPPETpublic static void merge(int[] a, int[] b, int n, int m) { 	int k = m + n - 1; // Index of last location of array b 	int i = n - 1; // Index of last element in array b 	int j = m - 1; // Index of last element in array a 	// Start comparing from the last element and merge a and b while (i >= 0 && j >= 0) { 	if (a[i] > b[j]) { 		a[k--] = a[i--]; 	} else { 		a[k--] = b[j--]; 	} 	} 	while (j >= 0) { 		a[k--] = b[j--]; 	} } CODE_END#H3#@38.	Complexity of sorting algorithm.img#@http://infopulseukraine.com/Global/Blog/Timsort/img_timsort_1.pngH3#@39.	Quick Sorthttp://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gifCODE_START#START_SNIPPETint partition(int arr[], int left, int right){      int i = left, j = right;      int tmp;      int pivot = arr[(left + right) / 2];           while (i <= j) {            while (arr[i] < pivot)                  i++;            while (arr[j] > pivot)                  j--;            if (i <= j) {                  tmp = arr[i];                  arr[i] = arr[j];                  arr[j] = tmp;                  i++;                  j--;            }      };           return i;} void quickSort(int arr[], int left, int right) {      int index = partition(arr, left, right);      if (left < index - 1)            quickSort(arr, left, index - 1);      if (index < right)            quickSort(arr, index, right);}CODE_END#H3#@40.	Implement external sort.CODE_START#START_SNIPPETCODE_END#H3#@41.	Implement tri tree.CODE_START#START_SNIPPETCODE_END#H3#@42.	There is a building of 100 floors. If an egg drops from the Nth floor or above it will break. If it’s dropped from any floor below, it will not break. You’re given 2 eggs. Find N, while minimizing the number of drops for the worst case.Observation: Regardless of how we drop Egg1, Egg2 must do a linear search. i.e., if Egg1 breaks between floor 10 and 15, we have to check every floor in between with the Egg2The Approach:A First Try: Suppose we drop an egg from the 10th floor, then the 20th, …»»	If the first egg breaks on the first drop (Floor 10), then we have at most 10 drops total. »»	If the first egg breaks on the last drop (Floor 100), then we have at most 19 drops total (floors 10, 20, ...,90, 100, then 91 through 99). »»	That’s pretty good, but all we’ve considered is the absolute worst case. We should do some “load balancing” to make those two cases more even. Goal: Create a system for dropping Egg1 so that the most drops required is consistent, whether Egg1 breaks on the first drop or the last drop.1.	A perfectly load balanced system would be one in which Drops of Egg1 + Drops of Egg2 is always the same, regardless of where Egg1 broke. 2.	For that to be the case, since each drop of Egg1 takes one more step, Egg2 is allowed one fewer step. 3.	We must, therefore, reduce the number of steps potentially required by Egg2 by one drop each time. For example, if Egg1 is dropped on Floor 20 and then Floor 30, Egg2 is potentially required to take 9 steps. When we drop Egg1 again, we must reduce potential Egg2 steps to only 8. That is, we must drop Egg1 at floor 39. 4.	We know, therefore, Egg1 must start at Floor X, then go up by X-1 floors, then X-2, …, until it gets to 100. 5.	Solve for X+(X-1)+(X-2)+…+1 = 100. X(X+1)/2 = 100 -> X = 14 We go to Floor 14, then 27, then 39, … This takes 14 steps maximum.H3#@43.	There are one hundred closed lockers in a hallway. A man begins by opening all one hundred lockers. Next, he closes every second locker. Then he goes to every third locker and closes it if it is open or opens it if it is closed (e.g., he toggles every third locker). After his one hundredth pass in the hallway, in which he toggles only locker number one hundred, how many lockers are open?A door n is toggled once for each factor of n, including itself and 1. That is, door 15 is toggled on round 1, 3, 5, and 15.Question: When would a door be left open?Answer: A door is left open if the number of factors (x) is odd. You can think about this by pairing factors off as an open and a close. If there’s one remaining, the door will be open.Question: When would x be odd?Answer: x is odd if n is a perfect square. Here’s why: pair n’s factors by their complements. For example, if n is 36, the factors are (1, 36), (2, 18), (3, 12), (4, 9), (6, 6). Note that (6, 6) only contributes 1 factor, thus giving n an odd number of factors.Question: How many perfect squares are there?Answer: There are 10 perfect squares. You could count them (1, 4, 9, 16, 25, 36, 49, 64, 81, 100), or you could simply realize that you can take the numbers 1 through 10 and square them (1*1, 2*2, 3*3, ..., 10*10).Therefore, there are 10 lockers open.H3#@44.	Given a matrix in which each row and each column is sorted, write a method to find an element in it. »»	Rows are sorted left to right in ascending order. Columns are sorted top to bottom in ascending order. »»	Matrix is of size MxN. This algorithm works by elimination. Every move to the left (--col) eliminates all the elements below the current cell in that column. Likewise, every move down eliminates all the elements to the left of the cell in that row.CODE_START#START_SNIPPETboolean FindElem(int[][] mat, int elem, int M, int N) { 	int row = 0;	int col = N-1;	while (row < M && col >= 0) { 		if (mat[row][col] == elem) { 			return true; 		} else if (mat[row][col] > elem) { 			col--;		} else { 			row++; 		} 	} 	return false; } CODE_END#H3#@45.	On a Cartesian plane, if two lines do not intersect, they must be parallel with each other. Hence, their slopes must be the same. If their slopes are different, they would intersect. A line is represented as ax+by+c=0 on a Cartesian plane and the slope is given by -a/b Therefore if -a1/b1 != -a2/b2 for two lines, they will intersect.CODE_START#START_SNIPPETpublic class Line {    static final double epsilon = 0.000001;    public double slope;    public double yintercept;     public Line(double s, double y) {        slope = s;        yintercept = y;    }     public boolean intersect(Line line2) {        return Math.abs(slope - line2.slope) > epsilon                || Math.abs(yintercept - line2.yintercept) < epsilon;    }}CODE_END#1.	Two lines can be the same. In that case, we assume they intersects (overlap).2.	We need to consider the floating system in a computer. Never use == to compare two floating numbers.H3#@46.	Find a line to cut two squares in half.Line should pass through center of both square.CODE_START#START_SNIPPET    private double topLeftX;    private double topLeftY;    private double edge;     public Square(double topLeftX, double topLeftY, double edge) {        super();        this.topLeftX = topLeftX;        this.topLeftY = topLeftY;        this.edge = edge;    }     Pair<Double> getCenter() {        return new Pair<Double>(topLeftX + edge / 2, topLeftY - edge / 2);    }} public class Line {    private double slope;    private double intercept;     public Line(double slope, double intercept) {        super();        this.slope = slope;        this.intercept = intercept;    }} public static Line getLine(Square a, Square b) {    Pair<Double> centerA = a.getCenter();    Pair<Double> centerB = b.getCenter();     if (centerA.equals(centerB)) {        return new Line(centerA.getY() / centerA.getX(), 0);    } else {        double slope = (centerB.getY() - centerA.getY())                / (centerB.getX() - centerA.getX());        double intercept = (centerB.getX() * centerA.getY() - centerA                .getX() * centerB.getY())                / (centerB.getX() - centerA.getX());        return new Line(slope, intercept);    }}CODE_END#H3#@47.	Find a line which passes the most number of points.We have a bunch of line segments, represented as a slope and y-intercept, and we want to find the most common slope and y-intercept. How can we find the most common one? This is really no different than the old "find the most common number in a list of numbers" problem. We just iterate through the lines segments and use a hash table to count the number of times we've seen each line.CODE_START#START_SNIPPETpublic static Line findBestLine(GraphPoint[] points) {    Line bestLine = null;    HashMap<Line, Integer> line_count = new HashMap<Line, Integer>();    for (int i = 0; i < points.length; i++) {        for (int j = i + 1; j < points.length; j++) {            Line line = new Line(points[i], points[j]);            if (!line_count.containsKey(line)) {                line_count.put(line, 0);            }            line_count.put(line, line_count.get(line) + 1);            if (bestLine == null                    || line_count.get(line) > line_count.get(bestLine)) {                bestLine = line;            }        }    }    return bestLine;} public class Line {    private static double epsilon = .0001;    public double slope;    public double intercept;    private boolean infinite_slope = false;     public Line(GraphPoint p, GraphPoint q) {        if (Math.abs(p.x - q.x) > epsilon) { // if x’s are different            slope = (p.y - q.y) / (p.x - q.x); // compute slope            intercept = p.y - slope * p.x; // y intercept from y=mx+b        } else {            infinite_slope = true;            intercept = p.x; // x-intercept, since slope is infinite        }    }     public boolean isEqual(double a, double b) {        return (Math.abs(a - b) < epsilon);    }     @Override    public int hashCode() {        int sl = (int) (slope * 1000);        int in = (int) (intercept * 1000);        return sl | in;    }     @Override    public boolean equals(Object o) {        Line l = (Line) o;        if (isEqual(l.slope, slope) && isEqual(l.intercept, intercept)                && (infinite_slope == l.infinite_slope)) {            return true;        }        return false;    }}CODE_END#H3#@48. Calculate Square root of a given number.CODE_START#START_SNIPPETconst precistion_num = 0.00000001;double square_root(double x) {	double mid, low = 0.0, high = x;	while(low<high){	mid = (low+high)/2.0;	if(mid*mid<x)low = mid + precistion_num;	else high = mid - precistion_num;}	return mid;}CODE_END#